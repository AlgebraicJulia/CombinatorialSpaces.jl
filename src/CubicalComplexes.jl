export CubicalComplex, EmbeddedCubicalComplex2D

using StaticArrays: @SVector, SVector
using GeometryBasics: Point2d, Point3d, QuadFace
using LinearAlgebra: norm, diagm
using SparseArrays

import Base.show

using GeometryBasics
import GeometryBasics.Mesh

using Makie
import Makie: convert_arguments

abstract type HasCubicalComplex end

# True orientation of edges will be from smaller to greater vertex index
# TODO: Could add support for implicit points 
# x,y coordinates are generated by function that take values [1, nx], [1, ny]
# TODO: Make sure that non-uniform grids are being supported
mutable struct EmbeddedCubicalComplex2D <: HasCubicalComplex
  nx::Int
  ny::Int
  points::AbstractVector
end

# Basic structure is as follows:
# - Points are the only explicit information stored (along with how many are along x and y)
# - Because we operate in a grid, we can deduce which points appear in a certain edge/quad
# - Knowing points, we can derive lengths and areas
# - Points go from left to right and bottom to top
# - Edges are horizontal from top to bottom and vertical from left to right
# - Quads follow the same pattern as points
# - Edge vertices go from low to high (edge orientation follows low to high)
# - Quad vertices are stored counterclockwise, (starting from base point)

function Base.show(io::IO, s::HasCubicalComplex)
  println(io, "Mesh Information:\n")
  println(io, "Vertices: $(nv(s))")
  println(io, "Edges   : $(ne(s))")
  println(io, "Quads   : $(nquads(s))\n")

  println(io, "Points:")
  for (i, p) in enumerate(points(s))
    println(io, "$i: $p")
  end

  println(io, "\nEdges:")
  for i in edges(s)
    println(io, "$i: $(edge_vertices(s, i))")
  end

  println(io, "\nQuads:")
  for i in quadrilaterals(s)
    println(io, "$i: $(quad_edges(s, i))")
  end
end

# Getters
nx(s::HasCubicalComplex) = s.nx
ny(s::HasCubicalComplex) = s.ny

points(s::HasCubicalComplex) = view(s.points, :)

# Counts and Iterators
nv(s::HasCubicalComplex) = nx(s) * ny(s)

nhe(s::HasCubicalComplex) = (nx(s) - 1) * ny(s)
nve(s::HasCubicalComplex) = nx(s) * (ny(s) - 1)
ne(s::HasCubicalComplex) = nhe(s) + nve(s)

nquads(s::HasCubicalComplex) = (nx(s) - 1) * (ny(s) - 1)

vertices(s::HasCubicalComplex) = 1:nv(s)
edges(s::HasCubicalComplex) = 1:ne(s)
quadrilaterals(s::HasCubicalComplex) = 1:nquads(s)

# Coordinate representations can make certain operations easier
coord_to_vert(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nx(s)

point(s::HasCubicalComplex, v::Int) = getindex(points(s), v)
point(s::HasCubicalComplex, x::Int, y::Int) = point(s, coord_to_vert(s, x, y))

is_hedge(s::HasCubicalComplex, e::Int) = 1 <= e <= nhe(s)
is_vedge(s::HasCubicalComplex, e::Int) = nhe(s) < e <= ne(s)

# The src of an edge (the lower index vertice) will also be the base point
function src(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return e + ((e - 1) ÷ (nx(s) - 1))
  elseif is_vedge(s, e)
    return e - nhe(s)
  else
    return 0
  end
end

function tgt(s::HasCubicalComplex, e::Int)
  base_idx = src(s, e)
  if is_hedge(s, e)
    return base_idx + 1
  elseif is_vedge(s, e)
    return base_idx + nx(s)
  else
    return 0
  end
end

edge_vertices(s::HasCubicalComplex, e::Int) = SVector(src(s, e), tgt(s, e))

edge_length(s, e::Int) = norm(point(s, tgt(s, e)) - point(s, src(s, e)))

# Maps a quadrilateral to its base point (bottom left)
quad_to_vert(s::HasCubicalComplex, q::Int) = coord_to_vert(s, (q - 1) % (nx(s) - 1) + 1, (q - 1) ÷ (nx(s) - 1) + 1)

# Return from bottom left, ccw
function quad_vertices(s::HasCubicalComplex, q::Int)
  base_idx = quad_to_vert(s, q)
  return SVector(base_idx, base_idx + 1, base_idx + nx(s) + 1, base_idx + nx(s))
end

# Return bottom, top, left, right
function quad_edges(s::HasCubicalComplex, q::Int)
  shift = ((q - 1) ÷ (nx(s) - 1))
  SVector(q, q + nx(s) - 1, q + nhe(s) + shift, q + nhe(s) + shift + 1)
end

function quad_area(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[1]) * edge_length(s, es[3]) # bottom * left
end

on_topbound_vertex(s::HasCubicalComplex, v::Int) = (v + nx(s)) > nv(s)
on_botbound_vertex(s::HasCubicalComplex, v::Int) = (v - nx(s)) < 1
on_leftbound_vertex(s::HasCubicalComplex, v::Int) = (v - 1) % nx(s) == 0
on_rightbound_vertex(s::HasCubicalComplex, v::Int) = v % nx(s) == 0

dual_point(s::HasCubicalComplex, v::Int) = 0.25 * sum(map(x -> point(s, x), quad_vertices(s, v)))
dual_points(s::HasCubicalComplex) = map(q -> dual_point(s, q), quadrilaterals(s))

function top_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  on_topbound_vertex(s, v) && return 0
  return 0.5 * norm(point(s, v + nx(s)) - point(s, v))
end

function bot_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  on_botbound_vertex(s, v) && return 0
  return 0.5 * norm(point(s, v) - point(s, v - nx(s)))
end

function left_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  on_leftbound_vertex(s, v) && return 0
  return 0.5 * norm(point(s, v) - point(s, v - 1))
end

function right_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  on_rightbound_vertex(s, v) && return 0
  return 0.5 * norm(point(s, v + 1) - point(s, v))
end

function dual_edge_length(s::HasCubicalComplex, e::Int)
  v = src(s, e)
  if 1 <= e <= nhe(s) # Horizontal edge
    return top_dualsup_edge_length(s, v) + bot_dualsup_edge_length(s, v)
  else # Vertical edge
    return left_dualsup_edge_length(s, v) + right_dualsup_edge_length(s, v)  
  end
end

function dual_quad_area(s::HasCubicalComplex, q::Int)
  # v <=> dual_q index match
  h = top_dualsup_edge_length(s, q) + bot_dualsup_edge_length(s, q)
  w = left_dualsup_edge_length(s, q) + right_dualsup_edge_length(s, q)

  return h * w
end

### PLOTTING ###

function GeometryBasics.Mesh(s::HasCubicalComplex)
  ps = map(q -> point(s, q), vertices(s))
  qs = map(q -> QuadFace{Int}(quad_vertices(s, q)), quadrilaterals(s))
  GeometryBasics.Mesh(ps, qs)
end

function convert_arguments(P::Union{Type{<:Makie.Wireframe},
                                    Type{<:Makie.Mesh},
                                    Type{<:Makie.Scatter}},
                           s::HasCubicalComplex)
  convert_arguments(P, GeometryBasics.Mesh(s))
end

plottype(::HasCubicalComplex) = GeometryBasics.Mesh

function plot_oneform(s::HasCubicalComplex, alpha)
  dps = dual_points(s)
  x = map(a -> dps[a][1], quadrilaterals(s))
  y = map(a -> dps[a][2], quadrilaterals(s))

  X,Y = sharp_pp(s, alpha)

  color = sqrt.(X.^2 + Y.^2)

  fig = Figure();
  ax = CairoMakie.Axis(fig[1,1])
  arrows2d!(ax, x, y, X, Y, color = color)
  wireframe!(ax, s)
  fig
end

### MESH HELPERS ###

function uniform_grid(lx::Real, ly::Real, nx::Int, ny::Int)
  ps = Point3d[]
  for y in range(0, ly, length = ny)
    for x in range(0, lx, length = nx)
      push!(ps, Point3d(x, y, 0))
    end
  end

  return EmbeddedCubicalComplex2D(nx, ny, ps)
end

### DEC OPERATORS ###

function exterior_derivative(::Val{0}, s::HasCubicalComplex)

  tot = 2 * ne(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  for e in edges(s)
    idx = 2 * e - 1
    v0, v1 = tgt(s, e), src(s, e)

    I[idx] = e
    I[idx + 1] = e

    J[idx] = v0
    J[idx + 1] = v1

    V[idx] = 1
    V[idx + 1] = -1
  end

  return sparse(I, J, V)
end

function exterior_derivative(::Val{1}, s::HasCubicalComplex)

  tot = 4 * nquads(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  orients = SVector(1,-1,-1,1)
  for q in quadrilaterals(s)
    idx = 4 * q - 3
    for (i, e) in enumerate(quad_edges(s, q))
      j = idx + i - 1
      I[j] = q
      J[j] = e
      V[j] = orients[i]
    end
  end

  return sparse(I, J, V)
end

dual_derivative(::Val{0}, s::HasCubicalComplex) = -transpose(exterior_derivative(Val(1), s))
dual_derivative(::Val{1}, s::HasCubicalComplex) = transpose(exterior_derivative(Val(0), s))

function wedge_product(::Val{(0,1)}, s::HasCubicalComplex, f, alpha)
  res = similar(alpha)

  for e in edges(s)
    res[e] = 0.5 * (getindex(f, src(s, e)) + getindex(f, tgt(s, e))) * alpha[e]
  end

  return res
end

function wedge_product(::Val{(0,2)}, s::HasCubicalComplex, f, alpha)
  res = similar(alpha)

  for q in quadrilaterals(s)
    v1, v2, v3, v4 = quad_vertices(s, q)
    res[q] = 0.25 * (getindex(f, v1) + getindex(f, v2) + getindex(f, v3) + getindex(f, v4)) * alpha[q]
  end

  return res
end

function wedge_product(::Val{(1,1)}, s::HasCubicalComplex, alpha, beta)
  res = zeros(eltype(alpha), nquads(s))

  # a ∧ b = (a[x]b[y] - a[y]b[x])dx ∧ dy
  for q in quadrilaterals(s)
    e1, e2, e3, e4 = quad_edges(s, q)
    res[q] = 0.25 * ((alpha[e1] + alpha[e2]) * (beta[e3] + beta[e4]) - (alpha[e3] + alpha[e4]) * (beta[e1] + beta[e2]))
  end

  return res
end

hodge_star(::Val{0}, s::HasCubicalComplex) = spdiagm(map(dq -> dual_quad_area(s, dq), vertices(s)))

function hodge_star(::Val{1}, s::HasCubicalComplex)
  e_lens = map(e -> edge_length(s, e), edges(s))
  de_lens = map(de -> dual_edge_length(s, de), edges(s))
  return spdiagm(e_lens ./ de_lens)
end

hodge_star(::Val{2}, s::HasCubicalComplex) = spdiagm(1 ./ map(q -> quad_area(s, q), quadrilaterals(s)))

inv_hodge_star(::Val{k}, s::HasCubicalComplex) where k = spdiagm(1 ./ diag(hodge_star(Val(k), s)))

laplacian(::Val{0}, s::HasCubicalComplex) = inv_hodge_star(Val(0), s) * dual_derivative(Val(1), s) * 
                                            hodge_star(Val(1), s) * exterior_derivative(Val(0), s)

function sharp_pp(s::HasCubicalComplex, alpha)
  X, Y = zeros(nquads(s)), zeros(nquads(s))
  for q in quadrilaterals(s)
    eb, et, el, er = quad_edges(s, q)
    X[q] = 0.5 * (alpha[eb] + alpha[et])
    Y[q] = 0.5 * (alpha[el] + alpha[er])
  end

  return X, Y
end