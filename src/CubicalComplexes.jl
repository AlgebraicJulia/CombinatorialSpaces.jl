export CubicalComplex, EmbeddedCubicalComplex2D

using StaticArrays: @SVector, SVector
using GeometryBasics: Point2d, Point3d, QuadFace
using LinearAlgebra: norm, diagm, diag
using SparseArrays

using KernelAbstractions

import Base.show

using GeometryBasics
import GeometryBasics.Mesh

using Makie
import Makie: convert_arguments

abstract type HasCubicalComplex end

# True orientation of edges will be from smaller to greater vertex index
# TODO: Could add support for implicit points 
# x,y coordinates are generated by function that take values [1, nx], [1, ny]
# TODO: Make sure that non-uniform grids are being supported
mutable struct EmbeddedCubicalComplex2D <: HasCubicalComplex
  nx::Int
  ny::Int
  points::AbstractVector{Point3d} # TODO: Turn this to an abstract point
end

# Basic structure is as follows:
# - Points are the only explicit information stored (along with how many are along x and y)
# - Because we operate in a grid, we can deduce which points appear in a certain edge/quad
# - Knowing points, we can derive lengths and areas
# - Points go from left to right and bottom to top
# - Edges are horizontal from top to bottom and vertical from left to right
# - Quads follow the same pattern as points
# - Edge vertices go from low to high (edge orientation follows low to high)
# - Quad vertices are stored counterclockwise, (starting from base point)

function Base.show(io::IO, s::HasCubicalComplex)
  println(io, "Mesh Information:\n")
  println(io, "Vertices: $(nv(s))")
  println(io, "Edges   : $(ne(s))")
  println(io, "Quads   : $(nquads(s))\n")

  println(io, "Points:")
  for (i, p) in enumerate(points(s))
    println(io, "$i: $p")
  end

  println(io, "\nEdges:")
  for i in edges(s)
    println(io, "$i: $(edge_vertices(s, i))")
  end

  println(io, "\nQuads:")
  for i in quadrilaterals(s)
    println(io, "$i: $(quad_edges(s, i))")
  end
end

# Getters
nx(s::HasCubicalComplex) = s.nx
ny(s::HasCubicalComplex) = s.ny

points(s::HasCubicalComplex) = view(s.points, :)

# Counts and Iterators
nv(s::HasCubicalComplex) = nx(s) * ny(s)

nhe(s::HasCubicalComplex) = (nx(s) - 1) * ny(s)
nve(s::HasCubicalComplex) = nx(s) * (ny(s) - 1)
ne(s::HasCubicalComplex) = nhe(s) + nve(s)

nquads(s::HasCubicalComplex) = (nx(s) - 1) * (ny(s) - 1)
nxquads(s::HasCubicalComplex) = nx(s) - 1
nyquads(s::HasCubicalComplex) = ny(s) - 1

ndv(s::HasCubicalComplex) = nquads(s)
nde(s::HasCubicalComplex) = ne(s)
ndquads(s::HasCubicalComplex) = nv(s)

vertices(s::HasCubicalComplex) = 1:nv(s)
edges(s::HasCubicalComplex) = 1:ne(s)
quadrilaterals(s::HasCubicalComplex) = 1:nquads(s)

horizontal_edges(s::HasCubicalComplex) = 1:nhe(s)
vertical_edges(s::HasCubicalComplex) = nhe(s)+1:ne(s)

dual_vertices(s::HasCubicalComplex) = 1:ndv(s)
dual_edges(s::HasCubicalComplex) = 1:nde(s)
dual_quadrilaterals(s::HasCubicalComplex) = 1:ndquads(s)

# Coordinate representations can make certain operations easier
coord_to_vert(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nx(s)

function coord_to_edge(s::EmbeddedCubicalComplex2D, x::Int, y::Int, is_h::Bool)
  if is_h
    return x + (y - 1) * (nx(s) - 1)
  else
    return x + (y - 1) * nx(s) + nhe(s)
  end
end

coord_to_quad(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nxquads(s)

function tensorfy_form(s::HasCubicalComplex, f)
    if length(f) == nv(s)
      nv(s) == ne(s) && @warn "Form ambiguous, defaulting to 0-form"
      return tensorfy_form(Val(0), s, f)
    elseif length(f) == ne(s)
      return tensorfy_form(Val(1), s, f)
    else
      return tensorfy_form(Val(2), s, f)
    end
end

tensorfy_form(::Val{0}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nx(s), ny(s)))

# This one has padding to make it into a 3D tensor
# function tensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, f)
#   padded_fh = vcat(reshape(f[horizontal_edges(s)], (nx(s)-1, ny(s))), zeros(ny(s))')
#   padded_fv = hcat(reshape(f[vertical_edges(s)], (nx(s), ny(s)-1)), zeros(ny(s)))
#   return cat(padded_fh, padded_fv, dims=3)
# end

function tensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, f)
  fh = reshape(f[horizontal_edges(s)], (nx(s)-1, ny(s)))
  fv = reshape(f[vertical_edges(s)], (nx(s), ny(s)-1))
  return (fh, fv)
end

get_hedge_form(g) = getindex(g, 1)
get_vedge_form(g) = getindex(g, 2)

tensorfy_form(::Val{2}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nxquads(s), nyquads(s)))

tensorfy_dual_form(::Val{k}, s::EmbeddedCubicalComplex2D, f) where k = tensorfy_form(Val(2 - k), s, f)

detensorfy_form(::Val{0}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nv(s)))

# function detensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, g)
#   return vcat(vec(g[1:nx(s)-1, 1:ny(s), 1]), vec(g[1:nx(s), 1:ny(s)-1, 2]))
# end

detensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, g) = vcat(vec(g[1]), vec(g[2]))

detensorfy_form(::Val{2}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nquads(s)))

init_tensor_form(::Val{0}, s::EmbeddedCubicalComplex2D) = zeros((nx(s), ny(s)))
init_tensor_form(::Val{1}, s::EmbeddedCubicalComplex2D) = (zeros((nx(s)-1, ny(s))), zeros(nx(s), ny(s)-1))
init_tensor_form(::Val{2}, s::EmbeddedCubicalComplex2D) = zeros((nxquads(s), nyquads(s)))

valid_quad_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nxquads(s)) && (1 <= y <= nyquads(s))
dual_zero_form_val(s::HasCubicalComplex, x::Int, y::Int, f; padding::Real = 0) = valid_quad_coor(s, x, y) ? f[x, y] : padding

valid_hedge_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s) - 1) && (1 <= y <= ny(s))
valid_vedge_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s)) && (1 <= y <= ny(s) - 1)

function dual_ones_form_val(s::HasCubicalComplex, h_or_v::Int, x::Int, y::Int, f; padding::Real = 0)
  if h_or_v == 1
    return valid_hedge_coor(s, x, y) ? get_hedge_form(f)[x, y] : padding
  elseif h_or_v == 2
    return valid_vedge_coor(s, x, y) ? get_vedge_form(f)[x, y] : padding
  else
    return padding
  end
end

# TODO: Remove this type assert, needed for performance now
point(s::HasCubicalComplex, v::Int) = getindex(s.points, v)::Point3d
point(s::HasCubicalComplex, x::Int, y::Int) = point(s, coord_to_vert(s, x, y))

is_hedge(s::HasCubicalComplex, e::Int) = 1 <= e <= nhe(s)
is_vedge(s::HasCubicalComplex, e::Int) = nhe(s) < e <= ne(s)

# The src of an edge (the lower index vertice) will also be the base point
function src(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return e + ((e - 1) ÷ (nx(s) - 1))
  elseif is_vedge(s, e)
    return e - nhe(s)
  else
    return 0
  end
end

function tgt(s::HasCubicalComplex, e::Int)
  base_idx = src(s, e)
  if is_hedge(s, e)
    return base_idx + 1
  elseif is_vedge(s, e)
    return base_idx + nx(s)
  else
    return 0
  end
end

edge_vertices(s::HasCubicalComplex, e::Int) = SVector(src(s, e), tgt(s, e))

edge_length(s, x::Int, y::Int, is_h::Bool) = edge_length(s, coord_to_edge(s, x, y, is_h))
edge_length(s, e::Int) = norm(point(s, tgt(s, e)) - point(s, src(s, e)))

# Maps a quadrilateral to its base point (bottom left)
quad_to_vert(s::HasCubicalComplex, q::Int) = coord_to_vert(s, (q - 1) % (nx(s) - 1) + 1, (q - 1) ÷ (nx(s) - 1) + 1)

# Return from bottom left, ccw
function quad_vertices(s::HasCubicalComplex, q::Int)
  base_idx = quad_to_vert(s, q)
  return SVector(base_idx, base_idx + 1, base_idx + nx(s) + 1, base_idx + nx(s))
end

# Return bottom, top, left, right
function quad_edges(s::HasCubicalComplex, q::Int)
  shift = ((q - 1) ÷ (nx(s) - 1))
  SVector(q, q + nx(s) - 1, q + nhe(s) + shift, q + nhe(s) + shift + 1)
end

function quad_width(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[1]) # bottom
end

function quad_height(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[3]) # left
end

quad_area(s::HasCubicalComplex, q::Int) = quad_width(s, q) * quad_height(s, q)

top_vertex(s::HasCubicalComplex, v::Int) = (v + nx(s)) > nv(s)
bot_vertex(s::HasCubicalComplex, v::Int) = (v - nx(s)) < 1
left_vertex(s::HasCubicalComplex, v::Int) = (v - 1) % nx(s) == 0
right_vertex(s::HasCubicalComplex, v::Int) = v % nx(s) == 0

left_edge(s::HasCubicalComplex, e::Int) = left_vertex(s, e - nhe(s))
right_edge(s::HasCubicalComplex, e::Int) = right_vertex(s, e - nhe(s))

function edge_quads(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return hedge_quads(s, e)
  elseif is_vedge(s, e)
    return vedge_quads(s, e)
  else
    return SVector(0, 0)
  end
end

function hedge_quads(s::HasCubicalComplex, e::Int)
  bottom = e - nxquads(s)
  if bottom < 1 
    bottom = 0
  end

  top = e
  if top > nquads(s)
    top = 0
  end

  return SVector(top, bottom)
end

function vedge_quads(s::HasCubicalComplex, e::Int)
  ve = e - nhe(s)

  left = left_edge(s, e) ? 0 : ve - 1
  right = right_edge(s, e) ? 0 : ve

  return SVector(left, right)
end

dual_point(s::HasCubicalComplex, v::Int) = 0.25 * sum(map(x -> point(s, x), quad_vertices(s, v)))
dual_points(s::HasCubicalComplex) = map(q -> dual_point(s, q), quadrilaterals(s))

function top_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  top_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v + nx(s)) - point(s, v))
end

function bot_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  bot_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v) - point(s, v - nx(s)))
end

function left_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  left_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v) - point(s, v - 1))
end

function right_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  right_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v + 1) - point(s, v))
end

dual_edge_length(s::HasCubicalComplex, x::Int, y::Int, is_h::Bool) = dual_edge_length(s, coord_to_edge(s, x, y, is_h))
function dual_edge_length(s::HasCubicalComplex, e::Int)
  v = src(s, e)
  if 1 <= e <= nhe(s) # Horizontal edge
    return top_dualsup_edge_length(s, v) + bot_dualsup_edge_length(s, v)
  elseif e <= ne(s) # Vertical edge
    return left_dualsup_edge_length(s, v) + right_dualsup_edge_length(s, v)  
  else
    return 0.0
  end
end

dual_quad_area(s::HasCubicalComplex, x::Int, y::Int) = dual_quad_area(s, coord_to_quad(s, x, y))
function dual_quad_area(s::HasCubicalComplex, q::Int)
  # v <=> dual_q index match
  h = top_dualsup_edge_length(s, q) + bot_dualsup_edge_length(s, q)
  w = left_dualsup_edge_length(s, q) + right_dualsup_edge_length(s, q)

  return h * w
end

### PLOTTING ###

function GeometryBasics.Mesh(s::HasCubicalComplex)
  ps = map(q -> point(s, q), vertices(s))
  qs = map(q -> QuadFace{Int}(quad_vertices(s, q)), quadrilaterals(s))
  GeometryBasics.Mesh(ps, qs)
end

function convert_arguments(P::Union{Type{<:Makie.Wireframe},
                                    Type{<:Makie.Mesh},
                                    Type{<:Makie.Scatter}},
                           s::HasCubicalComplex)
  convert_arguments(P, GeometryBasics.Mesh(s))
end

plottype(::HasCubicalComplex) = GeometryBasics.Mesh

# TODO: Add in generic kwargs
function plot_zeroform(s::HasCubicalComplex, f)
  fig = Figure();
  ax = CairoMakie.Axis(fig[1, 1])
  msh = CairoMakie.mesh!(ax, s, color=ω, colormap=:jet)
  Colorbar(fig[1, 2], msh)
  fig
end

function plot_oneform(s::HasCubicalComplex, alpha)
  dps = dual_points(s)
  x = map(a -> dps[a][1], quadrilaterals(s))
  y = map(a -> dps[a][2], quadrilaterals(s))

  X,Y = sharp_pd(s, alpha)

  color = sqrt.(X.^2 + Y.^2)

  fig = Figure();
  ax = CairoMakie.Axis(fig[1,1])
  arrows2d!(ax, x, y, X, Y, color = color)
  wireframe!(ax, s)
  fig
end

### MESH HELPERS ###

function uniform_grid(lx::Real, ly::Real, nx::Int, ny::Int)
  ps = Point3d[]
  for y in range(0, ly, length = ny)
    for x in range(0, lx, length = nx)
      push!(ps, Point3d(x, y, 0))
    end
  end

  return EmbeddedCubicalComplex2D(nx, ny, ps)
end

### DEC OPERATORS ###

function exterior_derivative(::Val{0}, s::HasCubicalComplex)

  tot = 2 * ne(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  for e in edges(s)
    idx = 2 * e - 1
    v0, v1 = tgt(s, e), src(s, e)

    I[idx] = e
    I[idx + 1] = e

    J[idx] = v0
    J[idx + 1] = v1

    V[idx] = 1
    V[idx + 1] = -1
  end

  return sparse(I, J, V)
end

function exterior_derivative(::Val{1}, s::HasCubicalComplex)

  tot = 4 * nquads(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  orients = SVector(1,-1,-1,1)
  for q in quadrilaterals(s)
    idx = 4 * q - 3
    for (i, e) in enumerate(quad_edges(s, q))
      j = idx + i - 1
      I[j] = q
      J[j] = e
      V[j] = orients[i]
    end
  end

  return sparse(I, J, V)
end

dual_derivative(::Val{0}, s::HasCubicalComplex) = -transpose(exterior_derivative(Val(1), s))
dual_derivative(::Val{1}, s::HasCubicalComplex) = transpose(exterior_derivative(Val(0), s))

function wedge_product(::Val{(0,1)}, s::HasCubicalComplex, f, alpha)
  res = similar(alpha)

  for e in edges(s)
    res[e] = 0.5 * (getindex(f, src(s, e)) + getindex(f, tgt(s, e))) * alpha[e]
  end

  return res
end

function wedge_product(::Val{(0,2)}, s::HasCubicalComplex, f, alpha)
  res = similar(alpha)

  for q in quadrilaterals(s)
    v1, v2, v3, v4 = quad_vertices(s, q)
    res[q] = 0.25 * (getindex(f, v1) + getindex(f, v2) + getindex(f, v3) + getindex(f, v4)) * alpha[q]
  end

  return res
end

function wedge_product(::Val{(1,1)}, s::HasCubicalComplex, alpha, beta)
  res = zeros(eltype(alpha), nquads(s))

  # a ∧ b = (a[x]b[y] - a[y]b[x])dx ∧ dy
  for q in quadrilaterals(s)
    e1, e2, e3, e4 = quad_edges(s, q)
    res[q] = 0.25 * ((alpha[e1] + alpha[e2]) * (beta[e3] + beta[e4]) - (alpha[e3] + alpha[e4]) * (beta[e1] + beta[e2]))
  end

  return res
end

hodge_star(::Val{0}, s::HasCubicalComplex) = spdiagm(map(dq -> dual_quad_area(s, dq), vertices(s)))

function hodge_star(::Val{1}, s::HasCubicalComplex)
  e_lens = map(e -> edge_length(s, e), edges(s))
  de_lens = map(de -> dual_edge_length(s, de), edges(s))
  return spdiagm(de_lens ./ e_lens)
end

hodge_star(::Val{2}, s::HasCubicalComplex) = spdiagm(1 ./ map(q -> quad_area(s, q), quadrilaterals(s)))

inv_hodge_star(::Val{k}, s::HasCubicalComplex) where k = spdiagm(1 ./ diag(hodge_star(Val(k), s)))

codifferential(::Val{1}, s::HasCubicalComplex) = inv_hodge_star(Val(0), s) * dual_derivative(Val(1), s) * hodge_star(Val(1), s)
codifferential(::Val{2}, s::HasCubicalComplex) = inv_hodge_star(Val(1), s) * dual_derivative(Val(0), s) * hodge_star(Val(2), s)

laplacian(::Val{0}, s::HasCubicalComplex) = codifferential(Val(1), s) * exterior_derivative(Val(0), s)
laplacian(::Val{1}, s::HasCubicalComplex) = exterior_derivative(Val(0), s) * codifferential(Val(1), s) + codifferential(Val(2), s) * exterior_derivative(Val(1), s) 
laplacian(::Val{2}, s::HasCubicalComplex) = exterior_derivative(Val(1), s) * codifferential(Val(2), s)

# Take primal 1-form and output dual vector field
function sharp_pd(s::HasCubicalComplex, alpha)
  X, Y = zeros(nquads(s)), zeros(nquads(s))
  for q in quadrilaterals(s)
    eb, et, el, er = quad_edges(s, q)
    X[q] = 0.5 * (alpha[eb] + alpha[et]) / quad_width(s, q)
    Y[q] = 0.5 * (alpha[el] + alpha[er]) / quad_height(s, q)
  end

  return X, Y
end

# Take dual 1-form and output dual vector field
function sharp_dd(s::HasCubicalComplex, alpha)
  X, Y = zeros(nquads(s)), zeros(nquads(s))
  for q in quadrilaterals(s)
    deb, det, del, der = quad_edges(s, q)

    X[q] = 0.5 * (alpha[del] / dual_edge_length(s, del) + alpha[der] / dual_edge_length(s, der))
    Y[q] = -0.5 * (alpha[deb] / dual_edge_length(s, deb) + alpha[det] / dual_edge_length(s, det))
  end

  return X, Y
end

# Take dual vector field and output dual 1-form
function flat_dd(s::HasCubicalComplex, X, Y)
  alpha = zeros(eltype(X), nde(s))

  for q in quadrilaterals(s)
    h = quad_height(q, s)
    w = quad_width(q, s)

    deb, det, del, der = quad_edges(s, q)
    alpha[deb] += 0.5 * h * Y[q]
    alpha[det] += 0.5 * h * Y[q]

    alpha[del] += 0.5 * w * X[q]
    alpha[der] += 0.5 * w * X[q]
  end

  return alpha
end

# Take dual vector field and output primal 1-form
# TODO: Might need to weight by dimensions of quad
function flat_dp(s::HasCubicalComplex, X, Y)
  alpha = zeros(eltype(X), nde(s))

  for q in quadrilaterals(s)
    h = quad_height(s, q)
    w = quad_width(s, q)

    eb, et, el, er = quad_edges(s, q)
    alpha[el] += 0.5 * h * Y[q]
    alpha[er] += 0.5 * h * Y[q]

    alpha[eb] += 0.5 * w * X[q]
    alpha[et] += 0.5 * w * X[q]
  end

  return alpha
end

### DEC OPERATOR KERNELS ###

function exterior_derivative!(res, ::Val{0}, f)
  backend = get_backend(f)

  @assert backend == get_hedge_form(res[1])
  @assert backend == get_vedge_form(res[2])

  for (i, edge_set) in enumerate(res)
    kernel = kernel_exterior_derivative_zero(backend, 32, size(edge_set))
    kernel(edge_set, i == 1, f, ndrange = size(edge_set))
  end
  return res
end

# TODO: Can move the horizontal/vertical handling into the higher level function
@kernel function kernel_exterior_derivative_zero(res, is_h::Bool, f)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  @inbounds if is_h # Horizontal edges
    res[idx] = f[x + 1, y] - f[x, y]
  else # Vertical edges
    res[idx] = f[x, y + 1] - f[x, y]
  end
end

function exterior_derivative!(res, ::Val{1}, f)
  backend = get_backend(res)

  @assert backend == get_backend(get_hedge_form(f))
  @assert backend == get_backend(get_vedge_form(f))

  kernel = kernel_exterior_derivative_one(backend, 32, size(res))
  kernel(res, f, ndrange = size(res))
  return res
end

@kernel function kernel_exterior_derivative_one(res, f)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  hes = get_hedge_form(f)
  ves = get_vedge_form(f)

  @inbounds res[idx] = hes[x, y] - hes[x, y + 1] - ves[x, y] + ves[x + 1, y]
end

function dual_derivative!(res, ::Val{0}, f; padding = 0)
  backend = get_backend(f)

  @assert backend == get_backend(f)

  for (i, edge_set) in enumerate(res)
    kernel = kernel_dual_derivative_zero(backend, 32, size(edge_set))
    kernel(edge_set, s, i == 1, f, padding, ndrange = size(edge_set))
  end
  return res
end

@kernel function kernel_dual_derivative_zero(res, s::HasCubicalComplex, is_h::Bool, f, padding)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  @inbounds if is_h # Horizontal edges
    res[idx] = dual_zero_form_val(s, x, y - 1, f, padding = padding) - dual_zero_form_val(s, x, y, f, padding = padding)
  else # Vertical edges
    res[idx] = dual_zero_form_val(s, x, y, f, padding = padding) - dual_zero_form_val(s, x - 1, y, f, padding = padding)
  end
end

function dual_derivative!(res, ::Val{1}, s::HasCubicalComplex, f; padding = 0)
  backend = get_backend(res)

  @assert backend == get_backend(get_hedge_form(f))
  @assert backend == get_backend(get_vedge_form(f))

  kernel = kernel_dual_derivative_one(backend, 32, size(res))
  kernel(res, s, f, padding, ndrange = size(res))
  return res
end

@kernel function kernel_dual_derivative_one(res, s::HasCubicalComplex, f, padding)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  # bottom, right, top, left, ccw orientation
  # ---->
  # | . |
  # V   V
  # ---->
  @inbounds res[idx] = dual_ones_form_val(s, 2, x, y - 1, f; padding = padding) - dual_ones_form_val(s, 1, x, y, f; padding = padding) - 
                       dual_ones_form_val(s, 2, x, y, f; padding = padding) + dual_ones_form_val(s, 1, x - 1, y, f; padding = padding)
end

function hodge_star!(res, ::Val{0}, s::HasCubicalComplex, f)
  backend = get_backend(res)

  @assert backend == get_backend(res)

  kernel = kernel_hodge_star_zero(backend, 32, size(res))
  kernel(res, s, f, ndrange = size(res))
  return res
end

@kernel function kernel_hodge_star_zero(res, s::HasCubicalComplex, f)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  @inbounds res[idx] = dual_quad_area(s, x, y) * f[idx]
end

function hodge_star!(res, ::Val{1}, s::HasCubicalComplex, f; inv::Bool = false)
  backend = get_backend(get_hedge_form(res))


  for (i, (res_set, f_set)) in enumerate(zip(res, f))
    args = (backend, 32, size(res_set))
    kernel = inv ? kernel_inv_hodge_star_one(args...) : kernel_hodge_star_one(args...)
    kernel(res_set, s, i == 1, f_set, ndrange = size(res_set))
  end
  return res
end

@kernel function kernel_hodge_star_one(res, s::HasCubicalComplex, h_or_v::Bool, f)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  @inbounds res[idx] = dual_edge_length(s, x, y, h_or_v) * f[idx] / edge_length(s, x, y, h_or_v)
end

@kernel function kernel_inv_hodge_star_one(res, s::HasCubicalComplex, h_or_v::Bool, f)
  idx = @index(Global, Cartesian)
  x, y = idx.I

  @inbounds res[idx] = edge_length(s, x, y, h_or_v) * f[idx] / dual_edge_length(s, x, y, h_or_v)
end

### PERIODIC HELPERS ###

function lr_boundary_verts_map!(v, s::HasCubicalComplex, depth::Int)
  for y in 1:ny(s)
    for x in 1:depth # Map right data to left boundary
      v[coord_to_vert(s, x, y)] = v[coord_to_vert(s, nx(s) - 2 * depth + x, y)]
    end
    for x in 1:depth # Map left data to right boundary
      v[coord_to_vert(s, nx(s) - x + 1, y)] = v[coord_to_vert(s, 2 * depth - x + 1, y)]
    end
  end

  return v
end

function tb_boundary_verts_map!(v, s::HasCubicalComplex, depth::Int)
  for x in 1:nx(s)
    for y in 1:depth # Map top data to bottom boundary
      v[coord_to_vert(s, x, y)] = v[coord_to_vert(s, x, ny(s) - 2 * depth + y)]
    end
    for y in 1:depth # Map bottom data to top boundary
      v[coord_to_vert(s, x, ny(s) - y + 1)] = v[coord_to_vert(s, x, 2 * depth - y + 1)]
    end
  end

  return v
end

function lr_boundary_quads_map!(v, s::HasCubicalComplex, depth::Int)
  for y in 1:nyquads(s)
    for x in 1:depth # Map right data to left boundary
      v[coord_to_vert(s, x, y)] = v[coord_to_vert(s, nxquads(s) - 2 * depth + x, y)]
    end
    for x in 1:depth # Map left data to right boundary
      v[coord_to_vert(s, nxquads(s) - x + 1, y)] = v[coord_to_vert(s, 2 * depth - x + 1, y)]
    end
  end

  return v
end

function tb_boundary_quads_map!(v, s::HasCubicalComplex, depth::Int)
  for x in 1:nxquads(s)
    for y in 1:depth # Map top data to bottom boundary
      v[coord_to_quad(s, x, y)] = v[coord_to_quad(s, x, nyquads(s) - 2 * depth + y)]
    end
    for y in 1:depth # Map bottom data to top boundary
      v[coord_to_quad(s, x, nyquads(s) - y + 1)] = v[coord_to_quad(s, x, 2 * depth - y + 1)]
    end
  end

  return v
end