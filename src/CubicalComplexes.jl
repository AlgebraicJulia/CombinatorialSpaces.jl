export CubicalComplex, EmbeddedCubicalComplex2D

using StaticArrays: @SVector, SVector
using GeometryBasics: Point2d, Point3d, QuadFace
using LinearAlgebra: norm, cross
using SparseArrays

import Base.show

using GeometryBasics
import GeometryBasics.Mesh

using Makie
import Makie: convert_arguments

abstract type HasCubicalComplex end

# True orientation of edges will be from smaller to greater vertex index
# TODO: Could add support for implicit points 
# x,y coordinates are generated by function that take values [1, nx], [1, ny]
# TODO: Make sure that non-uniform grids are being supported
mutable struct EmbeddedCubicalComplex2D <: HasCubicalComplex
  nx::Int
  ny::Int
  points::AbstractVector
end

# Basic structure is as follows:
# - Points are the only explicit information stored (along with how many are along x and y)
# - Because we operate in a grid, we can deduce which points appear in a certain edge/quad
# - Knowing points, we can derive lengths and areas
# - Points go from left to right and bottom to top
# - Edges are horizontal from top to bottom and vertical from left to right
# - Quads follow the same pattern as points
# - Edge vertices go from low to high (edge orientation follows low to high)
# - Quad vertices are stored counterclockwise, (starting from base point)

function Base.show(io::IO, s::HasCubicalComplex)
  println(io, "Mesh Information:\n")
  println(io, "Vertices: $(nv(s))")
  println(io, "Edges   : $(ne(s))")
  println(io, "Quads   : $(nquads(s))\n")

  println(io, "Points:")
  for (i, p) in enumerate(points(s))
    println(io, "$i: $p")
  end

  println(io, "\nEdges:")
  for i in edges(s)
    println(io, "$i: $(edge_vertices(s, i))")
  end

  println(io, "\nQuads:")
  for i in quadrilaterals(s)
    println(io, "$i: $(quad_edges(s, i))")
  end
end

# Getters
nx(s::HasCubicalComplex) = s.nx
ny(s::HasCubicalComplex) = s.ny

points(s::HasCubicalComplex) = view(s.points, :)

# Counts and Iterators
nv(s::HasCubicalComplex) = nx(s) * ny(s)

nhe(s::HasCubicalComplex) = (nx(s) - 1) * ny(s)
nve(s::HasCubicalComplex) = nx(s) * (ny(s) - 1)
ne(s::HasCubicalComplex) = nhe(s) + nve(s)

nquads(s::HasCubicalComplex) = (nx(s) - 1) * (ny(s) - 1)

vertices(s::HasCubicalComplex) = 1:nv(s)
edges(s::HasCubicalComplex) = 1:ne(s)
quadrilaterals(s::HasCubicalComplex) = 1:nquads(s)

# Coordinate representations can make certain operations easier
coord_to_vert(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nx(s)

point(s::HasCubicalComplex, v::Int) = getindex(points(s), v)
point(s::HasCubicalComplex, x::Int, y::Int) = point(s, coord_to_vert(s, x, y))

is_hedge(s::HasCubicalComplex, e::Int) = 1 <= e <= nhe(s)
is_vedge(s::HasCubicalComplex, e::Int) = nhe(s) < e <= ne(s)

# The src of an edge (the lower index vertice) will also be the base point
function src(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return e + ((e - 1) รท (nx(s) - 1))
  elseif is_vedge(s, e)
    return e - nhe(s)
  else
    return 0
  end
end

function tgt(s::HasCubicalComplex, e::Int)
  base_idx = src(s, e)
  if is_hedge(s, e)
    return base_idx + 1
  elseif is_vedge(s, e)
    return base_idx + nx(s)
  else
    return 0
  end
end

edge_vertices(s::HasCubicalComplex, e::Int) = SVector(src(s, e), tgt(s, e))

edge_length(s, e::Int) = norm(point(s, tgt(s, e)) - point(s, src(s, e)))

# Maps a quadrilateral to its base point (bottom left)
quad_to_vert(s::HasCubicalComplex, q::Int) = coord_to_vert(s, (q - 1) % (nx(s) - 1) + 1, (q - 1) รท (nx(s) - 1) + 1)

# Return from bottom left, ccw
function quad_vertices(s::HasCubicalComplex, q::Int)
  base_idx = quad_to_vert(s, q)
  return SVector(base_idx, base_idx + 1, base_idx + nx(s) + 1, base_idx + nx(s))
end

# Return bottom, top, left, right
function quad_edges(s::HasCubicalComplex, q::Int)
  shift = ((q - 1) รท (nx(s) - 1))
  SVector(q, q + nx(s) - 1, q + nhe(s) + shift, q + nhe(s) + shift + 1)
end

function quad_area(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[1]) * edge_length(s, es[3]) # bottom * left
end

### PLOTTING ###

function GeometryBasics.Mesh(s::HasCubicalComplex)
  ps = map(q -> point(s, q), vertices(s))
  qs = map(q -> QuadFace{Int}(quad_vertices(s, q)), quadrilaterals(s))
  GeometryBasics.Mesh(ps, qs)
end

function convert_arguments(P::Union{Type{<:Makie.Wireframe},
                                    Type{<:Makie.Mesh},
                                    Type{<:Makie.Scatter}},
                           s::HasCubicalComplex)
  convert_arguments(P, GeometryBasics.Mesh(s))
end

plottype(::HasCubicalComplex) = GeometryBasics.Mesh

### MESH HELPERS ###

function uniform_grid(lx::Real, ly::Real, nx::Int, ny::Int)
  ps = Point3d[]
  for y in range(0, ly, length = ny)
    for x in range(0, lx, length = nx)
      push!(ps, Point3d(x, y, 0))
    end
  end

  return EmbeddedCubicalComplex2D(nx, ny, ps)
end


### DEC OPERATORS ###

function exterior_derivative(::Val{0}, s::HasCubicalComplex)

  tot = 2 * ne(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  for e in edges(s)
    idx = 2 * e - 1
    v0, v1 = tgt(s, e), src(s, e)

    I[idx] = e
    I[idx + 1] = e

    J[idx] = v0
    J[idx + 1] = v1

    V[idx] = 1
    V[idx + 1] = -1
  end

  return sparse(I, J, V)
end

function exterior_derivative(::Val{1}, s::HasCubicalComplex)

  tot = 4 * nquads(s)
  I, J = zeros(Float64, tot), zeros(Float64, tot)
  V = zeros(Float64, tot)

  orients = SVector(1,-1,-1,1)
  for q in quadrilaterals(s)
    idx = 4 * q - 3
    for (i, e) in enumerate(quad_edges(s, q))
      j = idx + i - 1
      I[j] = q
      J[j] = e
      V[j] = orients[i]
    end
  end

  return sparse(I, J, V)
end
