abstract type HasCubicalComplex end

# True orientation of edges will be from smaller to greater vertex index
# TODO: Could add support for implicit points 
# x,y coordinates are generated by function that take values [1, nx], [1, ny]
# TODO: Make sure that non-uniform grids are being supported
mutable struct EmbeddedCubicalComplex2D <: HasCubicalComplex
  nx::Int
  ny::Int
  points::AbstractVector{Point3d} # TODO: Turn this to an abstract point
end

# Basic structure is as follows:
# - Points are the only explicit information stored (along with how many are along x and y)
# - Because we operate in a grid, we can deduce which points appear in a certain edge/quad
# - Knowing points, we can derive lengths and areas
# - Points go from left to right and bottom to top
# - Edges are horizontal from top to bottom and vertical from left to right
# - Quads follow the same pattern as points
# - Edge vertices go from low to high (edge orientation follows low to high)
# - Quad vertices are stored counterclockwise, (starting from base point)

function Base.show(io::IO, s::HasCubicalComplex)
  println(io, "Mesh Information:")
  println(io, "- Vertices: $(nv(s))")
  println(io, "- Edges   : $(ne(s))")
  println(io, "- Quads   : $(nquads(s))")
end

# Getters
nx(s::HasCubicalComplex) = s.nx
ny(s::HasCubicalComplex) = s.ny

points(s::HasCubicalComplex) = view(s.points, :)

# Counts and Iterators
nv(s::EmbeddedCubicalComplex2D) = nx(s) * ny(s)

nhe(s::EmbeddedCubicalComplex2D) = (nx(s) - 1) * ny(s)
nve(s::EmbeddedCubicalComplex2D) = nx(s) * (ny(s) - 1)
ne(s::EmbeddedCubicalComplex2D) = nhe(s) + nve(s)

nquads(s::EmbeddedCubicalComplex2D) = (nx(s) - 1) * (ny(s) - 1)
nxquads(s::EmbeddedCubicalComplex2D) = nx(s) - 1
nyquads(s::EmbeddedCubicalComplex2D) = ny(s) - 1

ndv(s::EmbeddedCubicalComplex2D) = nquads(s)
nde(s::EmbeddedCubicalComplex2D) = ne(s)
ndquads(s::EmbeddedCubicalComplex2D) = nv(s)

is_xedge(z::Int) = (z == 1)
is_yedge(z::Int) = (z == 2)

is_d_yedge(z::Int) = is_xedge(z)
is_d_xedge(z::Int) = is_yedge(z)

xedge(x::Int, y::Int) = (1, x, y); 
yedge(x::Int, y::Int) = (2, x, y);

xedges(g::Tuple) = getindex(g, 1)
yedges(g::Tuple) = getindex(g, 2)

vertices(s::EmbeddedCubicalComplex2D) = Iterators.product(1:nx(s), 1:ny(s))
function edges(s::EmbeddedCubicalComplex2D)
  return Iterators.flatten((Iterators.product(1, 1:nx(s)-1, 1:ny(s)), Iterators.product(2, 1:nx(s), 1:ny(s)-1)))
end
quadrilaterals(s::EmbeddedCubicalComplex2D) = Iterators.product(1:nxquads(s), 1:nyquads(s))

# abstract type AbstractDifferentialForm end

# mutable struct ZeroForm <: AbstractDifferentialForm
#   s::HasCubicalComplex
#   vals::AbstractArray{Float64}
# end

# const ZeroForm_Dual = ZeroForm

# ZeroForm(s::HasCubicalComplex, arr::AbstractVector) = ZeroForm(s, tensorfy(Val(0), s, arr))
# ZeroForm(s::HasCubicalComplex) = ZeroForm(s, init_tensor(Val(0), s))

# cube_complex(f::ZeroForm) = f.s
# vals(f::ZeroForm) = f.vals

# Base.show(io::IO, f::ZeroForm) = Base.show(io, vals(f))

# valid_vertex(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s)) && (1 <= y <= ny(s))
# getindex(f::ZeroForm, x::Int, y::Int; padding::Real = 0.0) = valid_vertex(cube_complex(f), x, y) ? getindex(vals(f), x, y) : padding
# getindex(f::ZeroForm, idx::CartesianIndex{2}; padding::Real = 0.0) = getindex(f, idx...; padding = padding)

function tensorfy(s::EmbeddedCubicalComplex2D, f)
    if length(f) == nv(s)
      nv(s) == ne(s) && @warn "Form ambiguous, defaulting to 0-form"
      return tensorfy(Val(0), s, f)
    elseif length(f) == ne(s)
      return tensorfy(Val(1), s, f)
    else
      return tensorfy(Val(2), s, f)
    end
end

tensorfy(::Val{0}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nx(s), ny(s)))

# # This one has padding to make it into a 3D tensor
# function tensorfy(::Val{1}, s::EmbeddedCubicalComplex2D, f)
#   padded_fh = vcat(reshape(f[begin:nhe(s)], (nx(s)-1, ny(s))), zeros(ny(s))')
#   padded_fv = hcat(reshape(f[nhe(s)+1:end], (nx(s), ny(s)-1)), zeros(ny(s)))
#   return cat(padded_fh, padded_fv, dims=3)
# end

function tensorfy(::Val{1}, s::EmbeddedCubicalComplex2D, f)
  fh = reshape(f[begin:nhe(s)], (nx(s)-1, ny(s)))
  fv = reshape(f[nhe(s)+1:end], (nx(s), ny(s)-1))
  return (fh, fv)
end

tensorfy(::Val{2}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nxquads(s), nyquads(s)))

tensorfy_d(::Val{k}, s::EmbeddedCubicalComplex2D, f) where k = tensorfy(Val(2 - k), s, f)

detensorfy(::Val{0}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nv(s)))

# function detensorfy(::Val{1}, s::EmbeddedCubicalComplex2D, g)
#   return vcat(vec(g[1:nx(s)-1, 1:ny(s), 1]), vec(g[1:nx(s), 1:ny(s)-1, 2]))
# end

detensorfy(::Val{1}, s::EmbeddedCubicalComplex2D, g) = vcat(vec(g[1]), vec(g[2]))

detensorfy(::Val{2}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nquads(s)))

detensorfy_d(::Val{k}, s::EmbeddedCubicalComplex2D, g) where k = detensorfy(Val(2-k), s, g)

init_tensor(::Val{0}, s::EmbeddedCubicalComplex2D) = zeros((nx(s), ny(s)))
init_tensor(::Val{1}, s::EmbeddedCubicalComplex2D) = (zeros((nx(s)-1, ny(s))), zeros(nx(s), ny(s)-1))
init_tensor(::Val{2}, s::EmbeddedCubicalComplex2D) = zeros((nxquads(s), nyquads(s)))

init_tensor_d(::Val{k}, s::EmbeddedCubicalComplex2D) where k = init_tensor(Val(2-k), s)

valid_vertex(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s)) && (1 <= y <= ny(s))
valid_xedge(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s) - 1) && (1 <= y <= ny(s))
valid_yedge(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s)) && (1 <= y <= ny(s) - 1)
valid_quad(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nxquads(s)) && (1 <= y <= nyquads(s))

get_onef(f, z::Int, x::Int, y::Int) = f[z][x, y]
set_onef!(f, val::Real, z::Int, x::Int, y::Int) = f[z][x, y] = val

get_zerodf(s::HasCubicalComplex, f, x::Int, y::Int; padding::Real = 0.0) = valid_quad(s, x, y) ? f[x, y] : padding

function get_onedf(s::HasCubicalComplex, f, z::Int, x::Int, y::Int; padding::Real = 0.0)
  if is_xedge(z)
    return valid_xedge(s, x, y) ? xedges(f)[x, y] : padding
  elseif is_yedge(z)
    return valid_yedge(s, x, y) ? yedges(f)[x, y] : padding
  else
    return padding
  end
end

coord_to_vert(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = x + (y - 1) * nx(s)

coord_to_xedge(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = x + (y - 1) * (nx(s) - 1)
coord_to_yedge(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = x + (y - 1) * nx(s) + nhe(s)
coord_to_edge(s::EmbeddedCubicalComplex2D, z::Int, x::Int, y::Int) = is_xedge(z) ? coord_to_xedge(s, x, y) : coord_to_yedge(s, x, y)

coord_to_quad(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = x + (y - 1) * nxquads(s)

coords_to_verts(s::HasCubicalComplex, coords::AbstractVector) = map(v -> coord_to_vert(s, v...), coords)

coords_to_xedges(s::HasCubicalComplex, coords::AbstractVector) = map(e -> coord_to_xedge(s, e...), coords)
coords_to_yedges(s::HasCubicalComplex, coords::AbstractVector) = map(e -> coord_to_yedge(s, e...), coords)
coords_to_edges(s::HasCubicalComplex, coords::AbstractVector) = map(e -> coord_to_edge(s, e...), coords)

coords_to_quads(s::HasCubicalComplex, coords::AbstractVector) = map(q -> coord_to_quad(s, q...), coords)


# TODO: Remove this type assert, needed for performance now
point(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = point(s, coord_to_vert(s, x, y))::Point3d
point(s::HasCubicalComplex, v::Int) = getindex(s.points, v)

# The src of an edge (which is either the leftmost or bottommost point)
xe_src(x::Int, y::Int) = (x, y)
ye_src(x::Int, y::Int) = (x, y)
xe_tgt(x::Int, y::Int) = (x + 1, y)
ye_tgt(x::Int, y::Int) = (x, y + 1)

src(z::Int, x::Int, y::Int) = is_xedge(z) ? xe_src(x, y) : ye_src(x, y)
tgt(z::Int, x::Int, y::Int) = is_xedge(z) ? xe_tgt(x, y) : ye_tgt(x, y)

xedge_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = norm(point(s, xe_tgt(x, y)...) - point(s, xe_src(x, y)...))
yedge_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = norm(point(s, ye_tgt(x, y)...) - point(s, ye_src(x, y)...))

edge_len(s::EmbeddedCubicalComplex2D, z::Int, x::Int, y::Int) = is_xedge(z) ? xedge_len(s, x, y) : yedge_len(s, x, y)

# For quads to boundary vertices
q_bl_v(x::Int, y::Int) = (x, y)
q_br_v(x::Int, y::Int) = (x + 1, y)
q_tr_v(x::Int, y::Int) = (x + 1, y + 1)
q_tl_v(x::Int, y::Int) = (x, y + 1)

# Bottom left, ccw
quad_vertices(x::Int, y::Int) = SVector(q_bl_v(x, y), q_br_v(x, y), q_tr_v(x, y), q_tl_v(x, y))

# For quads to boundary edges
q_b_xe(x::Int, y::Int) = (x, y)
q_t_xe(x::Int, y::Int) = (x, y + 1)
q_l_ye(x::Int, y::Int) = (x, y)
q_r_ye(x::Int, y::Int) = (x + 1, y)

# Bottom, top, left, right
quad_edges(x::Int, y::Int) = SVector(q_b_xe(x, y), q_t_xe(x, y), q_l_ye(x, y), q_r_ye(x, y))

quad_width(s::HasCubicalComplex, x::Int, y::Int) = xedge_len(s, q_b_xe(x, y)...) # bottom
quad_height(s::HasCubicalComplex, x::Int, y::Int) = yedge_len(s, q_l_ye(x, y)...) # left

quad_area(s::HasCubicalComplex, x::Int, y::Int) = quad_width(s, x, y) * quad_height(s, x, y)
safe_quad_area(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = valid_quad(s, x, y) ? quad_area(s, x, y) : 0.0

# For horizontal edges to neighboring quads
xe_t_q(x::Int, y::Int) = (x, y)
xe_b_q(x::Int, y::Int) = (x, y - 1)

# For vertical edges to neighboring quads
ye_l_q(x::Int, y::Int) = (x - 1, y)
ye_r_q(x::Int, y::Int) = (x, y)

# Top/bottom, left/right
edge_quads(z::Int, x::Int, y::Int) = is_xedge(z) ? SVector(xe_t_q(x, y), xe_b_q(x, y)) : SVector(ye_l_q(x, y), ye_r_q(x, y))

d_xe_src(x::Int, y::Int) = ye_l_q(x, y)
d_ye_src(x::Int, y::Int) = xe_t_q(x, y)
d_xe_tgt(x::Int, y::Int) = ye_r_q(x, y)
d_ye_tgt(x::Int, y::Int) = xe_b_q(x, y)

d_src(z::Int, x::Int, y::Int) = is_d_xedge(z) ? d_xe_src(x, y) : d_ye_src(x, y)
d_tgt(z::Int, x::Int, y::Int) = is_d_xedge(z) ? d_xe_tgt(x, y) : d_ye_tgt(x, y)

# For vertices to neighboring edges
v_l_xe(x::Int, y::Int) = (x - 1, y)
v_r_xe(x::Int, y::Int) = (x, y)
v_t_ye(x::Int, y::Int) = (x, y)
v_b_ye(x::Int, y::Int) = (x, y - 1)

# Bottom, top, left, right
vertex_edges(x::Int, y::Int) = SVector(v_b_ye(x, y), v_t_ye(x, y), v_l_xe(x, y), v_r_xe(x, y))

# For vertices to neighboring quads
v_bl_q(x::Int, y::Int) = (x - 1, y - 1)
v_br_q(x::Int, y::Int) = (x, y - 1)
v_tr_q(x::Int, y::Int) = (x, y)
v_tl_q(x::Int, y::Int) = (x - 1, y)

# Bottom left, ccw
vertex_quads(x::Int, y::Int) = SVector(v_bl_q(x, y), v_br_q(x, y), v_tr_q(x, y), v_tl_q(x, y))

# Midpoint of bottom left to top right diagonal
dual_point(s::HasCubicalComplex, x::Int, y::Int) = 0.5 * (point(s, q_bl_v(x, y)...) + point(s, q_tr_v(x, y)...))

# Done by half dual edges (divided by quad) in case dual edge runs off grid
function d_yedge_thalf_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  x, y = xe_t_q(x, y)
  y <= nyquads(s) ? 0.5 * quad_height(s, x, y) : 0.0
end

function d_yedge_bhalf_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  x, y = xe_b_q(x, y)
  y >= 1 ? 0.5 * quad_height(s, x, y) : 0.0
end

d_yedge_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = d_yedge_thalf_len(s, x, y) + d_yedge_bhalf_len(s, x, y)

# Top, bottom
function d_yedge_ratio(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  top_len = d_yedge_thalf_len(s, x, y); bottom_len = d_yedge_bhalf_len(s, x, y)
  len = top_len + bottom_len
  return top_len / len, bottom_len / len
end

function d_xedge_rhalf_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  x, y = ye_r_q(x, y)
  x <= nxquads(s) ? 0.5 * quad_width(s, x, y) : 0.0
end

function d_xedge_lhalf_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  x, y = ye_l_q(x, y)
  x >= 1 ? 0.5 * quad_width(s, x, y) : 0.0
end

d_xedge_len(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = d_xedge_rhalf_len(s, x, y) + d_xedge_lhalf_len(s, x, y)

# Left, right
function d_xedge_ratio(s::EmbeddedCubicalComplex2D, x::Int, y::Int)
  left_len = d_xedge_lhalf_len(s, x, y); right_len = d_xedge_rhalf_len(s, x, y)
  len = left_len + right_len
  return left_len / len, right_len / len
end

d_edge_len(s::HasCubicalComplex, z::Int, x::Int, y::Int) = is_d_xedge(z) ? d_xedge_len(s, x, y) : d_yedge_len(s, x, y)

d_edge_ratio(s::HasCubicalComplex, z::Int, x::Int, y::Int) = is_d_xedge(z) ? d_xedge_ratio(s, x, y) : d_yedge_ratio(s, x, y)

function d_quad_area(s::HasCubicalComplex, x::Int, y::Int)
  return 0.25 * (safe_quad_area(s, v_bl_q(x, y)...) + safe_quad_area(s, v_br_q(x, y)...) +
    safe_quad_area(s, v_tr_q(x, y)...) + safe_quad_area(s, v_tl_q(x, y)...))
end

### MESH HELPERS ###

function uniform_grid(lx::Real, ly::Real, nx::Int, ny::Int)
  ps = Point3d[]
  for y in range(0, ly, length = ny)
    for x in range(0, lx, length = nx)
      push!(ps, Point3d(x, y, 0))
    end
  end

  return EmbeddedCubicalComplex2D(nx, ny, ps)
end
