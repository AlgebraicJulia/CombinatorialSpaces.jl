abstract type HasCubicalComplex end

# True orientation of edges will be from smaller to greater vertex index
# TODO: Could add support for implicit points 
# x,y coordinates are generated by function that take values [1, nx], [1, ny]
# TODO: Make sure that non-uniform grids are being supported
mutable struct EmbeddedCubicalComplex2D <: HasCubicalComplex
  nx::Int
  ny::Int
  points::AbstractVector{Point3d} # TODO: Turn this to an abstract point
end

# Basic structure is as follows:
# - Points are the only explicit information stored (along with how many are along x and y)
# - Because we operate in a grid, we can deduce which points appear in a certain edge/quad
# - Knowing points, we can derive lengths and areas
# - Points go from left to right and bottom to top
# - Edges are horizontal from top to bottom and vertical from left to right
# - Quads follow the same pattern as points
# - Edge vertices go from low to high (edge orientation follows low to high)
# - Quad vertices are stored counterclockwise, (starting from base point)

function Base.show(io::IO, s::HasCubicalComplex)
  println(io, "Mesh Information:\n")
  println(io, "Vertices: $(nv(s))")
  println(io, "Edges   : $(ne(s))")
  println(io, "Quads   : $(nquads(s))\n")

  println(io, "Points:")
  for (i, p) in enumerate(points(s))
    println(io, "$i: $p")
  end

  println(io, "\nEdges:")
  for i in edges(s)
    println(io, "$i: $(edge_vertices(s, i))")
  end

  println(io, "\nQuads:")
  for i in quadrilaterals(s)
    println(io, "$i: $(quad_edges(s, i))")
  end
end

# Getters
nx(s::HasCubicalComplex) = s.nx
ny(s::HasCubicalComplex) = s.ny

points(s::HasCubicalComplex) = view(s.points, :)

# Counts and Iterators
nv(s::HasCubicalComplex) = nx(s) * ny(s)

nhe(s::HasCubicalComplex) = (nx(s) - 1) * ny(s)
nve(s::HasCubicalComplex) = nx(s) * (ny(s) - 1)
ne(s::HasCubicalComplex) = nhe(s) + nve(s)

nquads(s::HasCubicalComplex) = (nx(s) - 1) * (ny(s) - 1)
nxquads(s::HasCubicalComplex) = nx(s) - 1
nyquads(s::HasCubicalComplex) = ny(s) - 1

ndv(s::HasCubicalComplex) = nquads(s)
nde(s::HasCubicalComplex) = ne(s)
ndquads(s::HasCubicalComplex) = nv(s)

vertices(s::HasCubicalComplex) = 1:nv(s)
edges(s::HasCubicalComplex) = 1:ne(s)
quadrilaterals(s::HasCubicalComplex) = 1:nquads(s)

horizontal_edges(s::HasCubicalComplex) = 1:nhe(s)
vertical_edges(s::HasCubicalComplex) = nhe(s)+1:ne(s)

dual_vertices(s::HasCubicalComplex) = 1:ndv(s)
dual_edges(s::HasCubicalComplex) = 1:nde(s)
dual_quadrilaterals(s::HasCubicalComplex) = 1:ndquads(s)

# Coordinate representations can make certain operations easier
coord_to_vert(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nx(s)

function coord_to_edge(s::EmbeddedCubicalComplex2D, x::Int, y::Int, is_h::Bool)
  if is_h
    return x + (y - 1) * (nx(s) - 1)
  else
    return x + (y - 1) * nx(s) + nhe(s)
  end
end

coord_to_quad(s::HasCubicalComplex, x::Int, y::Int) = x + (y - 1) * nxquads(s)

function tensorfy_form(s::HasCubicalComplex, f)
    if length(f) == nv(s)
      nv(s) == ne(s) && @warn "Form ambiguous, defaulting to 0-form"
      return tensorfy_form(Val(0), s, f)
    elseif length(f) == ne(s)
      return tensorfy_form(Val(1), s, f)
    else
      return tensorfy_form(Val(2), s, f)
    end
end

tensorfy_form(::Val{0}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nx(s), ny(s)))

# This one has padding to make it into a 3D tensor
# function tensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, f)
#   padded_fh = vcat(reshape(f[horizontal_edges(s)], (nx(s)-1, ny(s))), zeros(ny(s))')
#   padded_fv = hcat(reshape(f[vertical_edges(s)], (nx(s), ny(s)-1)), zeros(ny(s)))
#   return cat(padded_fh, padded_fv, dims=3)
# end

function tensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, f)
  fh = reshape(f[horizontal_edges(s)], (nx(s)-1, ny(s)))
  fv = reshape(f[vertical_edges(s)], (nx(s), ny(s)-1))
  return (fh, fv)
end

get_hedge_form(g) = getindex(g, 1)
get_vedge_form(g) = getindex(g, 2)

tensorfy_form(::Val{2}, s::EmbeddedCubicalComplex2D, f) = reshape(f, (nxquads(s), nyquads(s)))

tensorfy_dual_form(::Val{k}, s::EmbeddedCubicalComplex2D, f) where k = tensorfy_form(Val(2 - k), s, f)

detensorfy_form(::Val{0}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nv(s)))

# function detensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, g)
#   return vcat(vec(g[1:nx(s)-1, 1:ny(s), 1]), vec(g[1:nx(s), 1:ny(s)-1, 2]))
# end

detensorfy_form(::Val{1}, s::EmbeddedCubicalComplex2D, g) = vcat(vec(g[1]), vec(g[2]))

detensorfy_form(::Val{2}, s::EmbeddedCubicalComplex2D, g) = reshape(g, (nquads(s)))

init_tensor_form(::Val{0}, s::EmbeddedCubicalComplex2D) = zeros((nx(s), ny(s)))
init_tensor_form(::Val{1}, s::EmbeddedCubicalComplex2D) = (zeros((nx(s)-1, ny(s))), zeros(nx(s), ny(s)-1))
init_tensor_form(::Val{2}, s::EmbeddedCubicalComplex2D) = zeros((nxquads(s), nyquads(s)))

valid_quad_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nxquads(s)) && (1 <= y <= nyquads(s))
dual_zero_form_val(s::HasCubicalComplex, x::Int, y::Int, f; padding::Real = 0) = valid_quad_coor(s, x, y) ? f[x, y] : padding

valid_hedge_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s) - 1) && (1 <= y <= ny(s))
valid_vedge_coor(s::EmbeddedCubicalComplex2D, x::Int, y::Int) = (1 <= x <= nx(s)) && (1 <= y <= ny(s) - 1)

function dual_ones_form_val(s::HasCubicalComplex, h_or_v::Int, x::Int, y::Int, f; padding::Real = 0)
  if h_or_v == 1
    return valid_hedge_coor(s, x, y) ? get_hedge_form(f)[x, y] : padding
  elseif h_or_v == 2
    return valid_vedge_coor(s, x, y) ? get_vedge_form(f)[x, y] : padding
  else
    return padding
  end
end

# TODO: Remove this type assert, needed for performance now
point(s::HasCubicalComplex, v::Int) = getindex(s.points, v)::Point3d
point(s::HasCubicalComplex, x::Int, y::Int) = point(s, coord_to_vert(s, x, y))

is_hedge(s::HasCubicalComplex, e::Int) = 1 <= e <= nhe(s)
is_vedge(s::HasCubicalComplex, e::Int) = nhe(s) < e <= ne(s)

# The src of an edge (the lower index vertice) will also be the base point
function src(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return e + ((e - 1) รท (nx(s) - 1))
  elseif is_vedge(s, e)
    return e - nhe(s)
  else
    return 0
  end
end

function tgt(s::HasCubicalComplex, e::Int)
  base_idx = src(s, e)
  if is_hedge(s, e)
    return base_idx + 1
  elseif is_vedge(s, e)
    return base_idx + nx(s)
  else
    return 0
  end
end

src(x::Int, y::Int) = CartesianIndex(x, y)
function tgt(x::Int, y::Int, is_h::Bool)
  if is_h
    return CartesianIndex(x + 1, y)
  else
    return CartesianIndex(x, y + 1)
  end
end

edge_vertices(s::HasCubicalComplex, e::Int) = SVector(src(s, e), tgt(s, e))

edge_length(s, x::Int, y::Int, is_h::Bool) = edge_length(s, coord_to_edge(s, x, y, is_h))
edge_length(s, e::Int) = norm(point(s, tgt(s, e)) - point(s, src(s, e)))

# Maps a quadrilateral to its base point (bottom left)
quad_to_vert(s::HasCubicalComplex, q::Int) = coord_to_vert(s, (q - 1) % (nx(s) - 1) + 1, (q - 1) รท (nx(s) - 1) + 1)

# Return from bottom left, ccw
function quad_vertices(s::HasCubicalComplex, q::Int)
  base_idx = quad_to_vert(s, q)
  return SVector(base_idx, base_idx + 1, base_idx + nx(s) + 1, base_idx + nx(s))
end

# Return bottom, top, left, right
function quad_edges(s::HasCubicalComplex, q::Int)
  shift = ((q - 1) รท (nx(s) - 1))
  SVector(q, q + nx(s) - 1, q + nhe(s) + shift, q + nhe(s) + shift + 1)
end

# Return bottom, top, left, right
function quad_edges(x::Int, y::Int)
  SVector(CartesianIndex(x,y), CartesianIndex(x,y+1), 
    CartesianIndex(x,y), CartesianIndex(x+1,y))
end


function quad_width(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[1]) # bottom
end

function quad_height(s::HasCubicalComplex, q::Int)
  es = quad_edges(s, q)
  return edge_length(s, es[3]) # left
end

quad_area(s::HasCubicalComplex, q::Int) = quad_width(s, q) * quad_height(s, q)

top_vertex(s::HasCubicalComplex, v::Int) = (v + nx(s)) > nv(s)
bot_vertex(s::HasCubicalComplex, v::Int) = (v - nx(s)) < 1
left_vertex(s::HasCubicalComplex, v::Int) = (v - 1) % nx(s) == 0
right_vertex(s::HasCubicalComplex, v::Int) = v % nx(s) == 0

left_edge(s::HasCubicalComplex, e::Int) = left_vertex(s, e - nhe(s))
right_edge(s::HasCubicalComplex, e::Int) = right_vertex(s, e - nhe(s))

function edge_quads(s::HasCubicalComplex, e::Int)
  if is_hedge(s, e)
    return hedge_quads(s, e)
  elseif is_vedge(s, e)
    return vedge_quads(s, e)
  else
    return SVector(0, 0)
  end
end

function hedge_quads(s::HasCubicalComplex, e::Int)
  bottom = e - nxquads(s)
  if bottom < 1 
    bottom = 0
  end

  top = e
  if top > nquads(s)
    top = 0
  end

  return SVector(top, bottom)
end

function vedge_quads(s::HasCubicalComplex, e::Int)
  ve = e - nhe(s)

  left = left_edge(s, e) ? 0 : ve - 1
  right = right_edge(s, e) ? 0 : ve

  return SVector(left, right)
end

dual_point(s::HasCubicalComplex, v::Int) = 0.25 * sum(map(x -> point(s, x), quad_vertices(s, v)))
dual_points(s::HasCubicalComplex) = map(q -> dual_point(s, q), quadrilaterals(s))

function top_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  top_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v + nx(s)) - point(s, v))
end

function bot_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  bot_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v) - point(s, v - nx(s)))
end

function left_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  left_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v) - point(s, v - 1))
end

function right_dualsup_edge_length(s::HasCubicalComplex, v::Int)
  right_vertex(s, v) && return 0.0
  return 0.5 * norm(point(s, v + 1) - point(s, v))
end

dual_edge_length(s::HasCubicalComplex, x::Int, y::Int, is_h::Bool) = dual_edge_length(s, coord_to_edge(s, x, y, is_h))
function dual_edge_length(s::HasCubicalComplex, e::Int)
  v = src(s, e)
  if 1 <= e <= nhe(s) # Horizontal edge
    return top_dualsup_edge_length(s, v) + bot_dualsup_edge_length(s, v)
  elseif e <= ne(s) # Vertical edge
    return left_dualsup_edge_length(s, v) + right_dualsup_edge_length(s, v)  
  else
    return 0.0
  end
end

dual_quad_area(s::HasCubicalComplex, x::Int, y::Int) = dual_quad_area(s, coord_to_vert(s, x, y))
function dual_quad_area(s::HasCubicalComplex, q::Int)
  # v <=> dual_q index match
  h = top_dualsup_edge_length(s, q) + bot_dualsup_edge_length(s, q)
  w = left_dualsup_edge_length(s, q) + right_dualsup_edge_length(s, q)

  return h * w
end

### MESH HELPERS ###

function uniform_grid(lx::Real, ly::Real, nx::Int, ny::Int)
  ps = Point3d[]
  for y in range(0, ly, length = ny)
    for x in range(0, lx, length = nx)
      push!(ps, Point3d(x, y, 0))
    end
  end

  return EmbeddedCubicalComplex2D(nx, ny, ps)
end
