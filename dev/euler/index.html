<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Steady-State Euler Equations · CombinatorialSpaces.jl</title><meta name="title" content="Steady-State Euler Equations · CombinatorialSpaces.jl"/><meta property="og:title" content="Steady-State Euler Equations · CombinatorialSpaces.jl"/><meta property="twitter:title" content="Steady-State Euler Equations · CombinatorialSpaces.jl"/><meta name="description" content="Documentation for CombinatorialSpaces.jl."/><meta property="og:description" content="Documentation for CombinatorialSpaces.jl."/><meta property="twitter:description" content="Documentation for CombinatorialSpaces.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../simplicial_sets/">CombinatorialSpaces.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../simplicial_sets/">Simplicial sets</a></li><li><a class="tocitem" href="../discrete_exterior_calculus/">Discrete exterior calculus</a></li><li><a class="tocitem" href="../combinatorial_maps/">Combinatorial maps</a></li><li><a class="tocitem" href="../grid_laplace/">Solving Poisson&#39;s equation in multiscale</a></li><li><a class="tocitem" href="../meshes/">Meshes</a></li><li class="is-active"><a class="tocitem" href>Steady-State Euler Equations</a><ul class="internal"><li><a class="tocitem" href="#Euler-Equations"><span>Euler Equations</span></a></li><li><a class="tocitem" href="#Discretizing"><span>Discretizing</span></a></li><li><a class="tocitem" href="#First-Case"><span>First Case</span></a></li><li><a class="tocitem" href="#Second-Case"><span>Second Case</span></a></li><li><a class="tocitem" href="#Third-Case"><span>Third Case</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Steady-State Euler Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Steady-State Euler Equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/main/docs/src/euler.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Steady-State-Euler-Equations"><a class="docs-heading-anchor" href="#Steady-State-Euler-Equations">Steady-State Euler Equations</a><a id="Steady-State-Euler-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State-Euler-Equations" title="Permalink"></a></h1><p>CombinatorialSpaces provides meshes and discrete operators amenable for solving many types of physics and multi-physics problems. For example, CombinatorialSpaces powers the <a href="https://github.com/AlgebraicJulia/Decapodes.jl">Decapodes</a> library provides a DSL for generating initial-value problem simulations, such as <a href="https://algebraicjulia.github.io/Decapodes.jl/dev/navier_stokes/ns/">co-rotating vortices on a sphere governed by Navier-Stokes</a>.</p><p>On this page, we will use CombinatorialSpaces directly to solve a steady-state problem.</p><h2 id="Euler-Equations"><a class="docs-heading-anchor" href="#Euler-Equations">Euler Equations</a><a id="Euler-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Equations" title="Permalink"></a></h2><p>The Euler equations are a concise model of fluid flow, but this model still demonstrates some interesting differential operators:</p><p class="math-container">\[\frac{\partial \textbf{u}^\flat}{\partial t} + \pounds_u \textbf{u}^\flat - \frac{1}{2} \textbf{d}(\textbf{u}^\flat(\textbf{u})) = - \frac{1}{\rho} \textbf{d} p + \textbf{b}^\flat.\]</p><p>See Marsden, Ratiu, and Abraham&#39;s &quot;Manifolds, Tensor Analysis, and Applications&quot; for an overview in the exterior calculus.</p><p>Here, we see an exterior derivative, <a href="../simplicial_sets/#CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n"><code>d</code></a>, a Lie derivative, <a href="../discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.ℒ-Union{Tuple{n}, Tuple{HasDeltaSet, EForm{T} where T, DualForm{n, T} where T}} where n"><code>ℒ</code></a>, and an interior product, <a href="../discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.interior_product-Union{Tuple{n}, Tuple{HasDeltaSet, EForm{T} where T, DualForm{n, T} where T}} where n"><code>interior_product</code></a>.</p><h2 id="Discretizing"><a class="docs-heading-anchor" href="#Discretizing">Discretizing</a><a id="Discretizing-1"></a><a class="docs-heading-anchor-permalink" href="#Discretizing" title="Permalink"></a></h2><p>Let&#39;s examine some particular cases of these equations. For both, we need a mesh and some discrete differential operators.</p><pre><code class="language-julia hljs">using CairoMakie, CombinatorialSpaces, StaticArrays
using CombinatorialSpaces.DiscreteExteriorCalculus: eval_constant_primal_form
using GeometryBasics: Point3d
using LinearAlgebra: norm

s = triangulated_grid(100,100,5,5,Point3d);
sd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3d}(s);
subdivide_duals!(sd, Barycenter());

f = Figure()
ax = CairoMakie.Axis(f[1,1])
wireframe!(ax, s)

f</code></pre><img src="96836006.png" alt="Example block output"/><p>Now that we have our mesh, let&#39;s allocate our discrete differential operators:</p><pre><code class="language-julia hljs">d0 = dec_dual_derivative(0, sd)
d1 = dec_differential(1, sd);
s1 = dec_hodge_star(1, sd);
s2 = dec_hodge_star(2, sd);
ι1 = interior_product_dd(Tuple{1,1}, sd)
ι2 = interior_product_dd(Tuple{1,2}, sd)
ℒ1 = ℒ_dd(Tuple{1,1}, sd);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#36 (generic function with 1 method)</code></pre><h2 id="First-Case"><a class="docs-heading-anchor" href="#First-Case">First Case</a><a id="First-Case-1"></a><a class="docs-heading-anchor-permalink" href="#First-Case" title="Permalink"></a></h2><p>In this first case, we will explicitly provide initial values for <code>u</code>. We will solve for pressure and the time derivative of <code>u</code> and check that they are what we expect. Note that we will set the mass budget, <code>b</code>, to 0.</p><p>Let&#39;s provide a flow field of unit magnitude, static throughout the domain. We want to store this as a 1-form. We can create a 1-form by &quot;flattening&quot; a vector field, performing many line integrals to store values on the edges of the mesh. Since we want to store our flow as a &quot;dual&quot; 1-form (on the edges of the dual mesh), we can use the Hodge star operator to convert from a primal 1-form to a dual 1-form. Since the values of a 1-form can be unintuitive, we will &quot;sharpen&quot; the 1-form back to a vector field when visualizing.</p><pre><code class="language-julia hljs">X♯ = SVector{3,Float64}(1/√2,1/√2,0)
u = s1 * eval_constant_primal_form(sd, X♯)

plot_dvf(sd, u, title=&quot;Flow&quot;)</code></pre><img src="3a47deef.png" alt="Example block output"/><p>Let&#39;s look at the self-advection term, in which we take the lie derivative of <code>u</code> along itself, and subtract half of the gradient of its inner product. (See Marsden, Ratiu, and Abraham for a derivation.) Recall that our flow <code>u</code> is static throughout the domain, so we should expect this term to be 0 throughout the interior of the domain, where it is not affected by boundary conditions.</p><p>The Lie derivative encodes how a differential form changes along a vector field. For our case of many parallel streamlines, and in which the magnitude is identical everywhere, we expect such a quantity to be 0. However, when discretizing, we have to make some assumptions about what is happening &quot;outside&quot; of the domain, and these assumptions have implications on the data stored on the boundary of the domain. In our discretization, we assume the flow outside the domain is 0. Thus, our Lie derivative along the boundary points inward:</p><pre><code class="language-julia hljs">lie_u_u = ℒ1(u,u)

plot_dvf(sd, lie_u_u, title=&quot;Lie Derivative of Flow with Itself&quot;)</code></pre><img src="791a3ebb.png" alt="Example block output"/><pre><code class="language-julia hljs">selfadv = ℒ1(u,u) - 0.5*d0*ι1(u,u)

plot_dvf(sd, selfadv, title=&quot;Self-Advection&quot;)</code></pre><img src="d655a0d8.png" alt="Example block output"/><p>Now, let&#39;s solve for pressure. We can set up a Poisson problem on the divergence of the self-advection term we computed. Recall that divergence can be computed as <span>$\star d \star$</span>, and the Laplacian as <span>$d \star d \star$</span>. To solve a Poisson problem, we reverse the order of the operations, and take advantage of the fact that solving the inverse hodge star is equivalent to multiplying by the hodge star.</p><pre><code class="language-julia hljs">div(x) = s2 * d1 * (s1 \ x);
solveΔ(x) = float.(d0) \ (s1 * (float.(d1) \ (s2 \ x)))

p = (solveΔ ∘ div)(selfadv)

plot_dual0form(sd, p, title=&quot;Pressure&quot;)</code></pre><img src="3f4d62aa.png" alt="Example block output"/><p>We see that we have a nonzero pressure of exactly 2 across the interior of the domain.</p><pre><code class="language-julia hljs">dp = d0*p

plot_dvf(sd, dp, title=&quot;Pressure Gradient&quot;)</code></pre><img src="05c5cd44.png" alt="Example block output"/><p>Based on our initial conditions and the way that we computed pressure, we expect that the time derivative of <code>u</code> should be 0 on the interior of the domain, where it is not affected by boundary conditions.</p><pre><code class="language-julia hljs">∂ₜu = -selfadv - dp;

plot_dvf(sd, ∂ₜu, title=&quot;Time Derivative&quot;)</code></pre><img src="293611a5.png" alt="Example block output"/><p>We see that we do indeed find zero-vectors throughout the interior of the domain as expected.</p><h2 id="Second-Case"><a class="docs-heading-anchor" href="#Second-Case">Second Case</a><a id="Second-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Case" title="Permalink"></a></h2><p>For this second case, we will specify that the time derivative of <code>u</code> is 0. We will assume a constant pressure, and then analyze the steady-states of <code>u</code>. We will again ignore any mass budget, <code>b</code>, and recall the gradient of a constant function (here, pressure) is 0. Recall our formula:</p><p class="math-container">\[\frac{\partial \textbf{u}^\flat}{\partial t} + \pounds_u \textbf{u}^\flat - \frac{1}{2} \textbf{d}(\textbf{u}^\flat(\textbf{u})) = - \frac{1}{\rho} \textbf{d} p + \textbf{b}^\flat.\]</p><p>Setting appropriate terms to 0, we have:</p><p class="math-container">\[\pounds_u \textbf{u}^\flat - \frac{1}{2} \textbf{d}(\textbf{u}^\flat(\textbf{u})) = 0.\]</p><p>We already allocated our discrete differential operators. Let us solve.</p><pre><code class="language-julia hljs">using NLsolve

steady_flow(u) = ℒ1(u,u) - 0.5*d0*ι1(u,u)

starting_state = s1 * eval_constant_primal_form(sd, X♯)
sol = nlsolve(steady_flow, starting_state)

plot_dvf(sd, sol.zero, title=&quot;Steady State&quot;)</code></pre><img src="5dad2103.png" alt="Example block output"/><p>We note that this steady flow of all zero-vectors does indeed satisfy the constraints that we set.</p><h2 id="Third-Case"><a class="docs-heading-anchor" href="#Third-Case">Third Case</a><a id="Third-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Third-Case" title="Permalink"></a></h2><p>For this third case, we will again solve for <code>u</code>. However, we will set a Gaussian bubble of pressure at the center of the domain, and use Euler&#39;s method to solve Euler&#39;s equations.</p><p class="math-container">\[\frac{\partial \textbf{u}^\flat}{\partial t} = - \pounds_u \textbf{u}^\flat + \frac{1}{2} \textbf{d}(\textbf{u}^\flat(\textbf{u})) - \frac{1}{\rho} \textbf{d} p.\]</p><h3 id="Case-3.1:-Euler&#39;s-method"><a class="docs-heading-anchor" href="#Case-3.1:-Euler&#39;s-method">Case 3.1: Euler&#39;s method</a><a id="Case-3.1:-Euler&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Case-3.1:-Euler&#39;s-method" title="Permalink"></a></h3><pre><code class="language-julia hljs">center = [50.0, 50.0, 0.0]
gauss(pnt) = 2 + 50/(√(2*π*10))*ℯ^(-(norm(center-pnt)^2)/(2*10))
p = gauss.(sd[sd[:tri_center], :dual_point])

u = s1 * eval_constant_primal_form(sd, X♯)
du = copy(u)

function euler_equation!(du,u,p)
  du .= - ℒ1(u,u) + 0.5*d0*ι1(u,u) - d0*p
end

dt = 1e-3
function eulers_method()
  for _ in 0:dt:1
    euler_equation!(du,u,p)
    u .+= du * dt
  end
  u
end

eulers_method()

plot_dvf(sd, u, title=&quot;Flow&quot;)</code></pre><img src="4d6cfbf1.png" alt="Example block output"/><h3 id="Case-3.2:-Euler&#39;s-method-with-Projection"><a class="docs-heading-anchor" href="#Case-3.2:-Euler&#39;s-method-with-Projection">Case 3.2: Euler&#39;s method with Projection</a><a id="Case-3.2:-Euler&#39;s-method-with-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Case-3.2:-Euler&#39;s-method-with-Projection" title="Permalink"></a></h3><p>In Case 3.1, we solved Euler&#39;s equation directly using the method of lines. However, we assume that our flow, <code>u</code>, is incompressible. That is, <span>$\delta u = 0$</span>. In our finite updates, we did not check that the self-advection term is divergence free! One way to resolve this discrepancy is the &quot;Projection method&quot;, and this is intimately related to the Hodge decomposition of the flow. (See the <a href="https://en.wikipedia.org/wiki/Projection_method_(fluid_dynamics)">Wikipedia entry</a> on the projection method, for example.) Let&#39;s employ this method here.</p><pre><code class="language-julia hljs">u = s1 * eval_constant_primal_form(sd, X♯)
du = copy(u)

dt = 1e-3
u_int = zeros(ne(sd))
p_next = zeros(ntriangles(sd))

function euler_equation_with_projection!(u)
  u_int .= u .+ (- ℒ1(u,u) + 0.5*d0*ι1(u,u))*dt
  p_next .= (solveΔ ∘ div)(u_int/dt)
  u .= u_int - dt*(d0*p_next)
end

function eulers_method()
  for _ in 0:dt:1
    euler_equation_with_projection!(u)
  end
  u
end

eulers_method()

plot_dvf(sd, u, title=&quot;Flow, with Projection Method&quot;)</code></pre><img src="536df5e1.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meshes/">« Meshes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 27 January 2025 21:20">Monday 27 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
