var documenterSearchIndex = {"docs":
[{"location":"mg_benchmarks/#Multigrid-Benchmarks","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"","category":"section"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"In multigrid methods, there are tradeoffs between the levels of coarsening and the number of cycles performed. This docs page provides a simple demonstrations of the relative error of different methods, and the time of execution for these methods. This can help you choose the parameters to be used by your multigrid solves.","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"This code demonstrates a simple pipeline of creating a mesh, executing a multigrid solve, and plotting statistics about those executions.","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"using CombinatorialSpaces\nusing CairoMakie\nusing GeometryBasics: Point3d\nusing LinearAlgebra: norm\nconst Point3D = Point3{Float64}\n\ns = triangulated_grid(1, 1, 1/4, sqrt(3)/2*1/4, Point3D, false)\n\nfunction plot_residuals(s, title; cycles=1:50, timeit=false)\n  i = 0\n  function residuals(s, scheme::AbstractSubdivisionScheme, level, sizes)\n    series = PrimalGeometricMapSeries(s, scheme, level);\n    md = MGData(series, sd -> ∇²(0, sd), 3, scheme)\n    sd = finest_mesh(series)\n    push!(sizes, nv(sd))\n    L = first(md.operators)\n    # Observe: putting into range of the Laplacian for solvability.\n    b = L*rand(nv(sd))\n    u0 = zeros(nv(sd))\n    ress = map(cycles) do cyc\n      if timeit\n        i += 1\n        @elapsed u = multigrid_vcycles(u0,b,md,cyc)\n      else\n        u = multigrid_vcycles(u0,b,md,cyc)\n        norm(L*u-b)/norm(b)\n      end\n    end\n  end\n  bin_sizes = []\n  bin_ress = map(lev -> residuals(s, BinarySubdivision(), lev, bin_sizes), 2:4)\n  cub_sizes = []\n  cub_ress = map(lev -> residuals(s, CubicSubdivision(), lev, cub_sizes), 2:4)\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1];\n    title = \"Multigrid V-cycles, $title\",\n    yscale = timeit ? identity : log10,\n    ylabel = timeit ? \"execution time [s]\" : \"log₁₀(relative error)\",\n    xlabel = \"# cycles\")\n  colors = [:blue, :green, :orange]\n  for lev in 1:3\n    lines!(ax, bin_ress[lev],\n      label=\"binary, $(lev+1) levels, $(bin_sizes[lev]) vertices\",\n      linestyle=:solid, color=colors[lev])\n    lines!(ax, cub_ress[lev],\n      label=\"cubic, $(lev+1) levels, $(cub_sizes[lev]) vertices\",\n      linestyle=:dash, color=colors[lev])\n  end\n  f[1,2] = Legend(f,ax,\"Scheme\")\n  f\nend","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"plot_residuals(s, \"Residuals\")","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"We see that the log of the observed relative error is roughly in-line with the resolution of the base mesh used.","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"plot_residuals(s, \"Times\", timeit=true)","category":"page"},{"location":"mg_benchmarks/","page":"Multigrid Benchmarks","title":"Multigrid Benchmarks","text":"The spikes in these times are due to the fact that we are only executing the cycles a single time, for runtimes' sake. We observe that the timings are linear in the number of cycles. We observe that the slopes are greater for those meshes with more vertices, with the cubic-4-level method being the finest.","category":"page"},{"location":"simplicial_sets/#Simplicial-sets","page":"Simplicial sets","title":"Simplicial sets","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"As a core feature, this package provides data structures and algorithms for a flavor of simplicial sets known as semi-simplicial sets or delta sets. The first section explains how delta sets relate to simplicial complexes and other structures. Readers not interested in these distinctions may proceed directly to the next section, on delta sets.","category":"page"},{"location":"simplicial_sets/#Varieties-of-simplicial-stuff","page":"Simplicial sets","title":"Varieties of simplicial stuff","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"A wide, possibly bewildering variety of concepts fall under the heading of \"simplicial stuff,\" including:","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"simplicial complexes\nabstract simplicial complexes\nsimplicial sets\nsemi-simplicial sets, aka delta sets\naugmented simplicial sets\nsymmetric (simplicial) sets","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"The most familiar of these are simplicial complexes: coherent collections of n-simplices of different dimensions n embedded in an ambient Euclidean space. A simplicial complex may include points (n=0), line segments (n=1), triangles (n=2), tetrahedra (n=3), and higher-dimensional simplices. Of the structures listed here, only simplicial complexes are geometrical objects. All of the others can be seen as combinatorial abstractions of simplicial complexes.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"Abstract simplicial complexes are the oldest and most obvious abstraction of simplicial complexes, but nowadays mathematicians tend to prefer simplicial sets, which enjoy excellent algebraic properties. A simplicial set X consists of sets X_n, for n geq 0, of abstract n-simplices whose n+1 different faces are ordered and hence can be numerically indexed, via the face maps.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"In this package, we implement a variant of simplicial sets called semi-simplicial sets, or delta sets for short. The difference is that delta sets contain only the face maps, whereas simplicial sets also contain degeneracy maps. The main effect of the degeneracy maps is to enlarge the space of simplicial morphisms by allowing simplices to be \"collapsed\" onto lower-dimensional ones. Degeneracy maps have their pros and cons, and in the future we will likely provide simplicial sets as well as semi-simplicial ones. For more details, the paper by Greg Friedman is an excellent illustrated introduction to semi-simplicial and simplicial sets.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"Simplicial sets generalize graphs from one dimension to higher dimensions. The following table gives the precise correspondence between different flavors of simplicial stuff and graphs.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"1-dimensional n-dimensional\nstraight-line embedded graph simplicial complex\nsimple graph abstract simplicial complex\ngraph semi-simplicial set\nreflexive graph simplicial set\nsymmetric graph symmetric semi-simplicial set\nsymmetric reflexive graph symmetric simplicial set","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"note: Note\nIn this table, as in this package and the rest of the AlgebraicJulia  ecosystem, a graph without qualification is always a category theorist's graph (a directed multigraph), not a simple graph (an undirected graph with no self-loops or multiple edges).","category":"page"},{"location":"simplicial_sets/#Ordered-faces-in-geometric-applications","page":"Simplicial sets","title":"Ordered faces in geometric applications","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"That the faces of each simplex in a simplicial set are ordered is convenient for many purposes but may seem problematic for geometric applications, where the faces usually regarded as unordered.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"One solution to this problem would be to use symmetric simplicial sets, which are simplicial sets X equipped with an action of the symmetric group S_n+1 on the n-simplices X_n, for every n. This is computationally inconvenient because every \"unordered n-simplex\" is then really an equivalence class of (n+1) different n-simplices, a number that grows rapidly with n. At this time, symmetric simplicial sets of dimension greater than 1 are not implemented in this package.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"To simulate unordered simplicial sets, we instead adopt the convention of a choosing the representative of the equivalence class that orders the vertices of the simplex according to the integer IDs of the vertices. The simplicial set then \"presents\" a symmetric simplicial set in a canonical way. Indeed, the standard method of converting an abstract simplicial complex to a simplicial set is to pick a total ordering of its vertices. When following this convention, use the functions add_sorted_edge! and glue_sorted_triangle!, which automatically sort their inputs to ensure that the ordering condition is satisfied, rather than the functions add_edge! and glue_triangle!.","category":"page"},{"location":"simplicial_sets/#Delta-sets","page":"Simplicial sets","title":"Delta sets","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"A delta set X is a family of sets X_n for n = 012dots, called the n-simplices, together with functions","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"X(partial_n^i) X_n to X_n-1 qquad n geq 1 quad i=01dotsn","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"called the face maps, which must satisfy the semi-simplicial identities","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"X(partial_n+1^i) cdot X(partial_n^j)\n  = X(partial_n+1^j+1) cdot X(partial_n^i) X_n+1 to X_n-1\n  qquad 0 leq i leq j leq n","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"The function X(partial_n^i) X_n to X_n-1 gives the face of an n-simplex that is opposite its i-th vertex. The semi-simplicial identities then ensure that the faces of each n-simplex fit together properly, for example, that the edges of a 2-simplex actually form a triangle.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"In our implementation, the generic function ∂ supplies all the face maps of a delta set. Specifically, the function call ∂(i, n, x, k) gives the i-th face of the n-simplex in the delta set x with index k, and the call ∂(i, n, x) gives the i-faces of all n-simplices in the delta set x, which is a vector of integers.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"A finite delta set—the only kind supported here—has no simplices above a certain dimension. For any fixed N, an N-dimensional delta set is a delta set X such that X_n = emptyset for n  N. CombinatorialSpaces provides dedicated data structures for delta sets of a given dimension.","category":"page"},{"location":"simplicial_sets/#1D-delta-sets","page":"Simplicial sets","title":"1D delta sets","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"Since a one-dimensional delta set is the same thing as a graph, the type DeltaSet1D has the same methods as the type Graph in Catlab.Graphs, which should be consulted for further documentation.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"using CombinatorialSpaces # hide\n\ndset = DeltaSet1D()\nadd_vertices!(dset, 4)\nadd_edges!(dset, [1,2,2], [2,3,4])\ndset","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"One potentially confusing point is that the face map partial_1^0 gives the target vertex (the vertex of an edge opposite vertex 0), while the face map partial_1^1 gives the source vertex (the vertex of an edge opposite vertex 1).","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"@assert ∂(1,0,dset) == tgt(dset)\n@assert ∂(1,1,dset) == src(dset)","category":"page"},{"location":"simplicial_sets/#2D-delta-sets","page":"Simplicial sets","title":"2D delta sets","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"Two-dimensional delta sets, comprised of vertices, edges, and triangles, are supplied by the type DeltaSet2D. There are two ways to add triangles to a delta set. If appropriately arranged edges have already been added, a triangle having those edges as boundary can be added using the add_triangle! function. However, it often more convenient to use the glue_triangle! function, which takes vertices rather than edges as arguments, creating any boundary edges that do not already exist.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"For example, the following 2D delta set has the shape of a triangulated commutative square.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"using CombinatorialSpaces # hide\n\ndset = DeltaSet2D()\nadd_vertices!(dset, 4)\nglue_triangle!(dset, 1, 2, 3)\nglue_triangle!(dset, 1, 4, 3)\ndset","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"As the table above illustrates, only the edges of each triangle are explicitly stored. The vertices of a triangle can be accessed using the function triangle_vertices. The correctness of this function depends on the semi-simplicial identities.","category":"page"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"map(triangles(dset)) do t\n  triangle_vertices(dset, t)\nend","category":"page"},{"location":"simplicial_sets/#API-docs","page":"Simplicial sets","title":"API docs","text":"","category":"section"},{"location":"simplicial_sets/","page":"Simplicial sets","title":"Simplicial sets","text":"Modules = [ SimplicialSets ]\nPrivate = false","category":"page"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets","text":"Simplicial sets in one, two, and three dimensions.\n\nFor the time being, this module provides data structures only for delta sets, also known as semi-simplicial sets. These include the face maps but not the degeneracy maps of a simplicial set. In the future we may add support for simplicial sets. The analogy to keep in mind is that graphs are to semi-simpicial sets as reflexive graphs are to simplicial sets.\n\nAlso provided are the fundamental operators on simplicial sets used in nearly all geometric applications, namely the boundary and coboundary (discrete exterior derivative) operators. For additional operators, see the DiscreteExteriorCalculus module.\n\n\n\n\n\n","category":"module"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.AbstractDeltaSet1D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.AbstractDeltaSet1D","text":"Abstract type for one-dimensional delta sets, aka semi-simplicial sets.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.AbstractDeltaSet2D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.AbstractDeltaSet2D","text":"Abstract type for 2D delta sets.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.AbstractDeltaSet3D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.AbstractDeltaSet3D","text":"Abstract type for 3D delta sets.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.DeltaSet0D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.DeltaSet0D","text":"A 0-dimensional delta set, aka a set of vertices.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.DeltaSet1D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.DeltaSet1D","text":"A one-dimensional delta set, aka semi-simplicial set.\n\nDelta sets in 1D are isomorphic to graphs (in the category theorist's sense). The source and target of an edge can be accessed using the face maps ∂ (simplicial terminology) or src and tgt maps (graph-theoretic terminology). More generally, this type implements the graphs interface in Catlab.Graphs.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.DeltaSet2D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.DeltaSet2D","text":"A 2D delta set, aka semi-simplicial set.\n\nThe triangles in a semi-simpicial set can be interpreted in several ways. Geometrically, they are triangles (2-simplices) whose three edges are directed according to a specific pattern, determined by the ordering of the vertices or equivalently by the simplicial identities. This geometric perspective is present through the subpart names ∂e0, ∂e1, and ∂e2 and through the boundary map ∂. Alternatively, the triangle can be interpreted as a higher-dimensional link or morphism, going from two edges in sequence (which might be called src2_first and src2_last) to a transitive edge (say tgt2). This is the shape of the binary composition operation in a category.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.DeltaSet3D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.DeltaSet3D","text":"A 3D delta set, aka semi-simplicial set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.E","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.E","text":"Edge in simplicial set: alias for Simplex{1}.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet1D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet1D","text":"A one-dimensional, embedded, oriented delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D","text":"A two-dimensional, embedded, oriented delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet3D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet3D","text":"A three-dimensional, embedded, oriented delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.HasDeltaSet","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.HasDeltaSet","text":"Abstract type for C-sets that contain a delta set of some dimension.\n\nThis dimension could be zero, in which case the delta set consists only of vertices (0-simplices).\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.HasDeltaSet1D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.HasDeltaSet1D","text":"Abstract type for C-sets that contain a one-dimensional delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.HasDeltaSet2D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.HasDeltaSet2D","text":"Abstract type for C-sets containing a 2D delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.HasDeltaSet3D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.HasDeltaSet3D","text":"Abstract type for C-sets containing a 3D delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.OrientedDeltaSet1D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.OrientedDeltaSet1D","text":"A one-dimensional oriented delta set.\n\nEdges are oriented from source to target when edge_orientation is true/positive and from target to source when it is false/negative.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.OrientedDeltaSet2D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.OrientedDeltaSet2D","text":"A two-dimensional oriented delta set.\n\nTriangles are ordered in the cyclic order (012) when tri_orientation is true/positive and in the reverse order when it is false/negative.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.OrientedDeltaSet3D","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.OrientedDeltaSet3D","text":"A three-dimensional oriented delta set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.Simplex","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.Simplex","text":"Wrapper for simplex or simplices of dimension n.\n\nSee also: V, E, Tri.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.SimplexChain","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.SimplexChain","text":"Wrapper for simplex chain of dimension n.\n\nExample: EChain([2,-1,1]) represents the chain 2a-b+c in the simplicial set with edges a,b,c.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.SimplexForm","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.SimplexForm","text":"Wrapper for discrete form, aka cochain, in simplicial set.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.Tet","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.Tet","text":"Tetrahedron in simplicial set: alias for Simplex{3}.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.Tri","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.Tri","text":"Triangle in simplicial set: alias for Simplex{2}.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.V","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.V","text":"Vertex in simplicial set: alias for Simplex{0}.\n\n\n\n\n\n","category":"type"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.Lk","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.Lk","text":"Alias for the link operator link.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.St","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.St","text":"Alias for the star operator star, not the Hodge star.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.St̄","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.St̄","text":"Alias for the closed star operator closed_star, not the Hodge star.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.add_sorted_edge!-Tuple{HasDeltaSet1D, Int64, Int64}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.add_sorted_edge!","text":"Add edge to simplicial set, respecting the order of the vertex IDs.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.add_sorted_edges!-Tuple{HasDeltaSet1D, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.add_sorted_edges!","text":"Add edges to simplicial set, respecting the order of the vertex IDs.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.add_tetrahedron!-Tuple{HasDeltaSet3D, Vararg{Int64, 4}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.add_tetrahedron!","text":"Add a tetrahedron (3-simplex) to a simplicial set, given its boundary triangles.\n\nwarning: Warning\nThis low-level function does not check the simplicial identities. It is your responsibility to ensure they are satisfied. By contrast, tetrahedra added using the function glue_tetrahedron! always satisfy the simplicial identities, by construction. Thus it is often easier to use this function.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.add_triangle!-Tuple{HasDeltaSet2D, Int64, Int64, Int64}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.add_triangle!","text":"Add a triangle (2-simplex) to a simplicial set, given its boundary edges.\n\nIn the arguments to this function, the boundary edges have the order 0  1, 1  2, 0  2. i.e. (∂e₂, ∂e₀, ∂e₁).\n\nwarning: Warning\nThis low-level function does not check the simplicial identities. It is your responsibility to ensure they are satisfied. By contrast, triangles added using the function glue_triangle! always satisfy the simplicial identities, by construction. Thus it is often easier to use this function.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.boundary","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.boundary","text":"Alias for the face map and boundary operator ∂.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.closed_star-Union{Tuple{n}, Tuple{HasDeltaSet, Int64, AbstractVector, Type{Simplex{n}}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.closed_star","text":"Closed star of a vertex in a delta set.\n\nMunkres §2 ≈ \"The union of all simplices of s having v as a vertex.\"\n\nReturn a vector of simplex chains of dimensions 0 to n.\n\nNote that we do not return polytopes, but rather the simplices which together form such polytopes, in no particular order.\n\nThis is not the Hodge star ⋆.\n\nSee also star, link.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.coboundary","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.coboundary","text":"Alias for the coboundary operator d.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.d","text":"The discrete exterior derivative, aka the coboundary operator.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.dimension-Tuple{HasDeltaSet}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.dimension","text":"Calculate the dimension of a delta set from its acset schema. Assumes that vertices, edges, triangles, and tetrahedra are named :V, :E, :Tri, and :Tet respectively.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.edge_vertices-Tuple{HasDeltaSet1D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.edge_vertices","text":"Boundary vertices of an edge.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.exterior_derivative","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.exterior_derivative","text":"Alias for the discrete exterior derivative d.\n\n\n\n\n\n","category":"function"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.glue_sorted_tet_cube!-Tuple{HasDeltaSet3D, Vararg{Int64, 8}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.glue_sorted_tet_cube!","text":"Glue a tetrahedralized cube onto a simplicial set, respecting the order of the vertices.\n\nAfter sorting, the faces of the cube are: 1 5-4 0, 1 2-6 5, 1 2-3 0, 7 4-0 3, 7 3-2 6, 7 6-5 4, For each face, the diagonal edge is between those vertices connected by a dash. The internal diagonal is between vertices 1 and 7.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.glue_sorted_tetrahedron!-Tuple{HasDeltaSet3D, Vararg{Int64, 4}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.glue_sorted_tetrahedron!","text":"Glue a tetrahedron onto a simplicial set, respecting the order of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!-Tuple{HasDeltaSet2D, Int64, Int64, Int64}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!","text":"Glue a triangle onto a simplicial set, respecting the order of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.glue_tetrahedron!-Tuple{HasDeltaSet3D, Vararg{Int64, 4}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.glue_tetrahedron!","text":"Glue a tetrahedron onto a simplicial set, given its boundary vertices.\n\nIf a needed triangle between two vertices exists, it is reused (hence the \"gluing\"); otherwise, it is created. Necessary 1-simplices are likewise glued.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{HasDeltaSet2D, Int64, Int64, Int64}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.glue_triangle!","text":"Glue a triangle onto a simplicial set, given its boundary vertices.\n\nIf a needed edge between two vertices exists, it is reused (hence the \"gluing\"); otherwise, it is created.\n\nNote this function does not check whether a triangle [v₀,v₁,v₂] already exists.\n\nNote that this function does not rearrange v₀, v₁, v₂ in the way that minimizes the number of edges added. For example, if s is the DeltaSet with a single triangle [1,2,3] and edges [1,2], [2,3], [1,3], then gluing triangle [3,1,4] will add edges [3,1], [1,4], [3,4] so as to respect the simplicial identities. Note that the edges [1,3] and [3,1] are distinct! However, if the DeltaSet that one is creating is meant to be manifold-like, then adding triangles using only the command glue_sorted_triangle! guarantees that the minimal number of new edges are created.\n\nTODO: Reference a proof of the above claim.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.is_manifold_like-Tuple{AbstractDeltaSet1D}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.is_manifold_like","text":"Test whether a given simplicial complex is manifold-like.\n\nAccording to Hirani, \"all simplices of dimension k with 0  k  n - 1 must be the face of some simplex of dimension n in the complex.\" This function does not test that simplices do not overlap. Nor does it test that e.g. two triangles that share 2 vertices share an edge. Nor does it test that e.g. there is at most one triangle that connects 3 vertices. Nor does it test that the delta set consists of a single component.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.link-Union{Tuple{n}, Tuple{HasDeltaSet, Int64, Type{Simplex{n}}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.link","text":"Link of a vertex in a delta set.\n\nMunkres §2 ≈ \"The set St̄(v) - St(v).\"\n\nReturn a vector of simplex chains of dimensions 0 to n.\n\nThese are the simplices which are in the closed star of v, but not in the star of v.\n\nSee also star, closed_star.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.nonboundaries-Tuple{AbstractDeltaSet1D}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.nonboundaries","text":"Find the simplices which are not a face of another.\n\nFor an n-D oriented delta set, return a vector of 0 through n-1 chains consisting of the simplices that are not the face of another. Note that since n-simplices in an n-D oriented delta set are never the face of an (n+1)-simplex, these are excluded.\n\nWe choose the term \"nonboundaries\" so as not to be confused with the term \"nonface\", defined as those faces that are not in a simplical complex, whose corresponding monomials are the basis of the Stanley-Reisner ideal.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.nsimplices-Tuple{Int64, HasDeltaSet}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.nsimplices","text":"Number of simplices of given dimension in a simplicial set.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.orient!-Tuple{AbstractDeltaSet1D}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.orient!","text":"Consistently orient simplices in a simplicial set, if possible.\n\nTwo simplices with a common face are consistently oriented if they induce opposite orientations on the shared face. This function attempts to consistently orient all simplices of a given dimension and returns whether this has been achieved. Each connected component is oriently independently using the helper function orient_component!.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.orient_component!-Tuple{AbstractDeltaSet1D, Int64, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.orient_component!","text":"Consistently orient simplices in the same connected component, if possible.\n\nGiven an n-simplex and a choice of orientation for it, this function attempts to consistently orient all n-simplices that may be reached from it by traversing (n-1)-faces. The traversal is depth-first. If a consistent orientation is possible, the function returns true and the orientations are assigned; otherwise, it returns false and no orientations are changed.\n\nIf the simplicial set is not connected, the function orient! may be more convenient.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.orientation-Union{Tuple{n}, Tuple{HasDeltaSet, Simplex{n}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.orientation","text":"Orientation of simplex.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.point-Tuple{HasDeltaSet, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.point","text":"Point associated with vertex of complex.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.set_orientation!-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.set_orientation!","text":"Set orientation of simplex.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.simplices-Tuple{Int64, HasDeltaSet}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.simplices","text":"Simplices of given dimension in a simplicial set.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.star-Union{Tuple{n}, Tuple{HasDeltaSet, Int64, Type{Simplex{n}}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.star","text":"Star of a vertex in a delta set.\n\nMunkres §2 ≈ \"The union of the interiors of those simplices of s that have v as a vertex.\"\n\nReturn a vector of simplex chains of dimensions 0 to n.\n\nRecall that interior(σ) = σ - boundary(σ), Munkres §1.\n\nNote that we are returning interiors alone. This means, e.g. a triangle may be returned without one or more of its edges. Consequentially, the output of this function may not be storable in an ACSet.\n\nThis is not the Hodge star ⋆.\n\nSee also closed_star, link.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.tetrahedron_edges-Tuple{HasDeltaSet3D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.tetrahedron_edges","text":"Boundary edges of a tetrahedron.\n\nThis accessor assumes that the simplicial identities hold.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.tetrahedron_triangles-Tuple{HasDeltaSet3D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.tetrahedron_triangles","text":"Boundary triangles of a tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.tetrahedron_vertices-Tuple{HasDeltaSet3D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.tetrahedron_vertices","text":"Boundary vertices of a tetrahedron.\n\nThis accessor assumes that the simplicial identities hold.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.triangle_edges-Tuple{HasDeltaSet2D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.triangle_edges","text":"Boundary edges of a triangle.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.triangle_vertices-Tuple{HasDeltaSet2D, Vararg{Any}}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.triangle_vertices","text":"Boundary vertices of a triangle.\n\nThis accessor assumes that the simplicial identities hold.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.volume-Tuple{Any}","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.volume","text":"n-dimensional volume of n-simplex spanned by given n+1 points.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.volume-Union{Tuple{n}, Tuple{HasDeltaSet, Simplex{n}, Vararg{Any}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.volume","text":"n-dimensional volume of n-simplex in an embedded simplicial set.\n\n\n\n\n\n","category":"method"},{"location":"simplicial_sets/#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, HasDeltaSet, Simplex{n}}} where n","page":"Simplicial sets","title":"CombinatorialSpaces.SimplicialSets.∂","text":"Face map and boundary operator on simplicial sets.\n\nGiven numbers n and 0 <= i <= n and a simplicial set of dimension at least n, the ith face map is implemented by the call\n\n∂(n, i, s, ...)\n\nThe boundary operator on n-faces and n-chains is implemented by the call\n\n∂(n, s, ...)\n\nNote that the face map returns simplices, while the boundary operator returns chains (vectors in the free vector space spanned by oriented simplices).\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#Discrete-exterior-calculus","page":"Discrete exterior calculus","title":"Discrete exterior calculus","text":"","category":"section"},{"location":"discrete_exterior_calculus/","page":"Discrete exterior calculus","title":"Discrete exterior calculus","text":"CombinatorialSpaces.jl provides discrete differential operators defined on simplicial sets via the Discrete Exterior Calculus (DEC).","category":"page"},{"location":"discrete_exterior_calculus/","page":"Discrete exterior calculus","title":"Discrete exterior calculus","text":"There are two modules for these DEC operators. The first, CombinatorialSpaces.DiscreteExteriorCalculus, serves as our reference implementation. It is suitable for any manifold-like delta dual complex. The second, CombinatorialSpaces.FastDEC, offers more efficient operators, both in construction, and in execution time. The operators offered by both modules agree up to differences introduced by re-ordering floating-point operations.","category":"page"},{"location":"discrete_exterior_calculus/","page":"Discrete exterior calculus","title":"Discrete exterior calculus","text":"Certain operators in FastDEC are made more efficient by assuming that the delta dual complex has not been altered in any way after it is created and volumes have been assigned with subdivide_duals!. So, such operators should not be called on such a complex if it has been manually edited.","category":"page"},{"location":"discrete_exterior_calculus/#API-docs","page":"Discrete exterior calculus","title":"API docs","text":"","category":"section"},{"location":"discrete_exterior_calculus/","page":"Discrete exterior calculus","title":"Discrete exterior calculus","text":"Modules = [ DiscreteExteriorCalculus, FastDEC ]\nPrivate = false","category":"page"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus","text":"The discrete exterior calculus (DEC) for simplicial sets.\n\nThis module provides the dual complex associated with a delta set (the primal complex), which is a discrete incarnation of Hodge duality, as well as the many operators of the DEC that depend on it, such as the Hodge star, codifferential, wedge product, interior product, and Lie derivative. The main reference for this module is Hirani's 2003 PhD thesis.\n\n\n\n\n\n","category":"module"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex1D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex1D","text":"Abstract type for dual complex of a 1D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex2D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex2D","text":"Abstract type for dual complex of a 2D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex3D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.AbstractDeltaDualComplex3D","text":"Abstract type for dual complex of a 3D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.Barycenter","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.Barycenter","text":"Barycenter, aka centroid, of a simplex.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.Circumcenter","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.Circumcenter","text":"Circumcenter, or center of circumscribed circle, of a simplex.\n\nThe circumcenter is calculated by inverting the Cayley-Menger matrix, as explained by Westdendorp. This method of calculation is also used in the package AlphaShapes.jl.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex1D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex1D","text":"Dual complex of a one-dimensional delta set.\n\nThe data structure includes both the primal complex and the dual complex, as well as the mapping between them.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex2D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex2D","text":"Dual complex of a two-dimensional delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex3D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DeltaDualComplex3D","text":"Dual complex of a three-dimensional delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualChain","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualChain","text":"Wrapper for chain of dual cells of dimension n.\n\nIn an N-dimensional complex, the elementary dual simplices of each n-simplex together comprise the dual (N-n)-cell of the simplex. Using this correspondence, a basis for primal n-chains defines the basis for dual (N-n)-chains.\n\nnote: Note\nIn (Hirani 2003, Definition 3.4.1), the duality operator assigns a certain sign to each elementary dual simplex. For us, all of these signs should be regarded as positive because we have already incorporated them into the orientation of the dual simplices.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualE","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualE","text":"Edge in simplicial set: alias for Simplex{1}.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualForm","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualForm","text":"Wrapper for form, aka cochain, on dual cells of dimension n.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualSimplex","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualSimplex","text":"Wrapper for dual simplex or simplices of dimension D.\n\nSee also: DualV, DualE, DualTri.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualTet","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualTet","text":"Tetrahedron in simplicial set: alias for Simplex{3}.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualTri","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualTri","text":"Triangle in simplicial set: alias for Simplex{2}.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualV","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualV","text":"Vertex in simplicial set: alias for Simplex{0}.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.DualVectorField","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.DualVectorField","text":"Wrapper for vector field on dual vertices.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex1D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex1D","text":"Embedded dual complex of an embedded 1D delta set.\n\nAlthough they are redundant information, the lengths of the primal and dual edges are precomputed and stored.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex2D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex2D","text":"Embedded dual complex of an embedded 2D delta set.\n\nAlthough they are redundant information, the lengths and areas of the primal/dual edges and triangles are precomputed and stored.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex3D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.EmbeddedDeltaDualComplex3D","text":"Embedded dual complex of an embedded 3D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.Incenter","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.Incenter","text":"Incenter, or center of inscribed circle, of a simplex.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex1D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex1D","text":"Oriented dual complex of an oriented 1D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex2D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex2D","text":"Oriented dual complex of an oriented 2D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex3D","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.OrientedDeltaDualComplex3D","text":"Oriented dual complex of an oriented 3D delta set.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.PrimalVectorField","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.PrimalVectorField","text":"Wrapper for vector field on primal vertices.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.SimplexCenter","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.SimplexCenter","text":"A notion of \"geometric center\" of a simplex.\n\nSee also: geometric_center.\n\n\n\n\n\n","category":"type"},{"location":"discrete_exterior_calculus/#Catlab.Theories.:∧-Union{Tuple{l}, Tuple{k}, Tuple{HasDeltaSet, SimplexForm{k, T} where T, SimplexForm{l, T} where T}} where {k, l}","page":"Discrete exterior calculus","title":"Catlab.Theories.:∧","text":"Wedge product of discrete forms.\n\nThe wedge product of a k-form and an l-form is a (k+l)-form.\n\nThe DEC and related systems have several flavors of wedge product. This one is the discrete primal-primal wedge product introduced in (Hirani, 2003, Chapter 7) and (Desbrun et al 2005, Section 8). It depends on the geometric embedding and requires the dual complex. Note that we diverge from Hirani in that his formulation explicitly divides by (k+1)!. We do not do so in this computation.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#Catlab.Theories.Δ-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"Catlab.Theories.Δ","text":"Laplace-de Rham operator on discrete forms.\n\nThis linear operator on primal n-forms is defined by Δ = δ d + d δ. Restricted to 0-forms, it reduces to the negative of the Laplace-Beltrami operator ∇²: Δ f = -² f.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.:⋆-Tuple{Type{Val{1}}, AbstractDeltaDualComplex2D, GeometricHodge}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.:⋆","text":"Hodge star operator from primal 1-forms to dual 1-forms.\n\nThis specific hodge star implementation is based on the hodge star presented in (Ayoub et al 2020), which generalizes the operator presented in (Hirani 2003). This reproduces the diagonal hodge for a dual mesh generated under circumcentric subdivision and provides off-diagonal correction factors for meshes generated under other subdivision schemes (e.g. barycentric).\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.:⋆-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.:⋆","text":"Hodge star operator from primal n-forms to dual N-n-forms.\n\nnote: Note\nSome authors, such as (Hirani 2003) and (Desbrun 2005), use the symbol  for the duality operator on chains and the symbol * for the Hodge star operator on cochains. We do not explicitly define the duality operator and we use the symbol  for the Hodge star.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.:⋆⁻¹","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.:⋆⁻¹","text":"Alias for the inverse Hodge star operator ⋆⁻¹.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.codifferential","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.codifferential","text":"Alias for the codifferential operator δ.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_boundary-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_boundary","text":"Boundary of chain of dual cells.\n\nTranspose of dual_derivative.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_derivative-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_derivative","text":"Discrete exterior derivative of dual form.\n\nTranspose of dual_boundary. For more info, see (Desbrun, Kanso, Tong, 2008: Discrete differential forms for computational modeling, §4.5).\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_edge_vertices-Tuple{HasDeltaSet1D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_edge_vertices","text":"Boundary dual vertices of a dual edge.\n\nThis accessor assumes that the simplicial identities for the dual hold.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_point-Tuple{HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_point","text":"Point associated with dual vertex of complex.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_tetrahedron_vertices-Tuple{HasDeltaSet3D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_tetrahedron_vertices","text":"Boundary dual vertices of a dual tetrahedron.\n\nThis accessor assumes that the simplicial identities for the dual hold.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dual_triangle_vertices-Tuple{HasDeltaSet1D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dual_triangle_vertices","text":"Boundary dual vertices of a dual triangle.\n\nThis accessor assumes that the simplicial identities for the dual hold.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.dualize-Tuple{HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.dualize","text":"Calls the constructor for d's dual type on d, including parameters. Does not call subdivide_duals! on the result. Should work out of the box on new DeltaSet types if (1) their dual type has the same name as their primal type with \"Set\" substituted by \"DualComplex\" and (2) their dual type has the same parameter set as their primal type. At the time of writing (PR 117) only \"Embedded\" types fail criterion (2) and get special treatment.\n\nExamples\n\ns = EmbeddedDeltaSet2D{Bool,SVector{2,Float64}}() dualize(s)::EmbeddedDeltaDualComplex2D{Bool,Float64,SVector{2,Float64}}\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.edge_center-Tuple{HasDeltaSet1D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.edge_center","text":"Dual vertex corresponding to center of primal edge.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.elementary_duals-Union{Tuple{n}, Tuple{HasDeltaSet, Simplex{n}}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.elementary_duals","text":"List of elementary dual simplices corresponding to primal simplex.\n\nIn general, in an n-dimensional complex, the elementary duals of primal k-simplices are dual (n-k)-simplices. Thus, in 1D dual complexes, the elementary duals of...\n\nprimal vertices are dual edges\nprimal edges are (single) dual vertices\n\nIn 2D dual complexes, the elementary duals of...\n\nprimal vertices are dual triangles\nprimal edges are dual edges\nprimal triangles are (single) dual vertices\n\nIn 3D dual complexes, the elementary duals of...\n\nprimal vertices are dual tetrahedra\nprimal edges are dual triangles\nprimal triangles are dual edges\nprimal tetrahedra are (single) dual vertices\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.flat","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.flat","text":"Alias for the flat operator ♭.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.flat_sharp","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.flat_sharp","text":"Alias for the flat-sharp dual-to-primal interpolation operator ♭♯.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.flat_sharp_mat","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.flat_sharp_mat","text":"Alias for the flat-sharp dual-to-primal interpolation matrix ♭♯_mat.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.geometric_center","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.geometric_center","text":"Calculate the center of simplex spanned by given points.\n\nThe first argument is a list of points and the second specifies the notion of \"center\", via an instance of SimplexCenter.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.hodge_star","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.hodge_star","text":"Alias for the Hodge star operator ⋆.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.interior_product-Union{Tuple{n}, Tuple{HasDeltaSet, EForm{T} where T, DualForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.interior_product","text":"Interior product of a vector field (or 1-form) and a n-form.\n\nSpecifically, this operation is the primal-dual interior product defined in (Hirani 2003, Section 8.2) and (Desbrun et al 2005, Section 10). Thus it takes a primal vector field (or primal 1-form) and a dual n-forms and then returns a dual (n-1)-form.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.interior_product_flat-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.interior_product_flat","text":"Interior product of a 1-form and a n-form, yielding an (n-1)-form.\n\nUsually, the interior product is defined for vector fields; this function assumes that the flat operator ♭ (not yet implemented for primal vector fields) has already been applied to yield a 1-form.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.inv_hodge_star-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.inv_hodge_star","text":"Inverse Hodge star operator from dual N-n-forms to primal n-forms.\n\nConfusingly, this is not the operator inverse of the Hodge star ⋆ because it carries an extra global sign, in analogy to the smooth case (Gillette, 2009, Notes on the DEC, Definition 2.27).\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.laplace_beltrami","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.laplace_beltrami","text":"Alias for the Laplace-Beltrami operator ∇².\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.laplace_de_rham","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.laplace_de_rham","text":"Alias for the Laplace-de Rham operator Δ.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.lie_derivative","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.lie_derivative","text":"Alias for Lie derivative operator ℒ.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.lie_derivative_flat-Tuple{Int64, HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.lie_derivative_flat","text":"Lie derivative of n-form with respect to a 1-form.\n\nAssumes that the flat operator ♭ has already been applied to the vector field.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.p2_d2_interpolation-Tuple{HasDeltaSet2D}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.p2_d2_interpolation","text":" p2_d2_interpolation(sd::HasDeltaSet2D)\n\nGenerates a sparse matrix that converts data on primal 2-forms into data on dual 2-forms.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.primal_vertex-Union{Tuple{n}, Tuple{HasDeltaSet, DualSimplex{n}}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.primal_vertex","text":"Primal vertex associated with a dual simplex.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.sharp","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.sharp","text":"Alias for the sharp operator ♯.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.subdivide_duals!-Union{Tuple{point_type}, Tuple{EmbeddedDeltaDualComplex1D{_o, _l, point_type} where {_o, _l}, Any}} where point_type","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.subdivide_duals!","text":"Compute geometric subdivision for embedded dual complex.\n\nSupports different methods of subdivision through the choice of geometric center, as defined by geometric_center. In particular, barycentric subdivision and circumcentric subdivision are supported.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.subsimplices-Union{Tuple{n}, Tuple{HasDeltaSet, Simplex{n}}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.subsimplices","text":"List of dual simplices comprising the subdivision of a primal simplex.\n\nA primal n-simplex is always subdivided into (n+1) dual n-simplices, not be confused with the elementary_duals which have complementary dimension.\n\nThe returned list is ordered such that subsimplices with the same primal vertex appear consecutively.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.tetrahedron_center-Tuple{HasDeltaSet3D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.tetrahedron_center","text":"Dual vertex corresponding to center of primal tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.triangle_center-Tuple{HasDeltaSet2D, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.triangle_center","text":"Dual vertex corresponding to center of primal triangle.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.vertex_center-Tuple{HasDeltaSet, Vararg{Any}}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.vertex_center","text":"Dual vertex corresponding to center of primal vertex.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.wedge_product","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.wedge_product","text":"Alias for the wedge product operator ∧.\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.δ-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.δ","text":"Codifferential operator from primal n forms to primal n-1-forms.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.ℒ-Union{Tuple{n}, Tuple{HasDeltaSet, EForm{T} where T, DualForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.ℒ","text":"Lie derivative of n-form with respect to a vector field (or 1-form).\n\nSpecifically, this is the primal-dual Lie derivative defined in (Hirani 2003, Section 8.4) and (Desbrun et al 2005, Section 10).\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.∇²-Union{Tuple{n}, Tuple{HasDeltaSet, SimplexForm{n, T} where T}} where n","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.∇²","text":"Laplace-Beltrami operator on discrete forms.\n\nThis linear operator on primal n-forms defined by ² α = -δ d α, where δ is the codifferential and d is the exterior derivative.\n\nnote: Note\nFor following texts such as Abraham-Marsden-Ratiu, we take the sign convention that makes the Laplace-Beltrami operator consistent with the Euclidean Laplace operator (the divergence of the gradient). Other authors, such as (Hirani 2003), take the opposite convention, which has the advantage of being consistent with the Laplace-de Rham operator Δ.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♭-Tuple{HasDeltaSet, DualVectorField}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♭","text":"Flat operator converting vector fields to 1-forms.\n\nA generic function for discrete flat operators. Currently the DPP-flat from (Hirani 2003, Definition 5.5.2) and (Desbrun et al 2005, Definition 7.3) is implemented, as well as a primal-to-primal flat, which assumes linear-interpolation of the vector field across an edge, determined solely by the values at the endpoints.\n\nSee also: the sharp operator ♯.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♭♯-Tuple{HasDeltaSet2D, EForm{T} where T}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♭♯","text":"♭♯(s::HasDeltaSet2D, α::SimplexForm{1})\n\nMake a dual 1-form primal by chaining ♭ᵈᵖ♯ᵈᵈ.\n\nThis returns the given dual 1-form as a primal 1-form. See also ♭♯_mat.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♭♯_mat-Tuple{HasDeltaSet2D}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♭♯_mat","text":"♭♯_mat(s::HasDeltaSet2D)\n\nMake a dual 1-form primal by chaining ♭ᵈᵖ♯ᵈᵈ.\n\nThis returns a matrix which can be multiplied by a dual 1-form. See also ♭♯.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♯-Tuple{HasDeltaSet2D, DualForm{1, T} where T}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♯","text":"Sharp operator for converting dual 1-forms to dual vector fields.\n\nThis dual-dual sharp uses a method of local linear least squares to provide a tangent vector field.\n\nSee also: ♯_mat, which returns a matrix that encodes this operator.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♯-Tuple{HasDeltaSet2D, EForm{T} where T}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♯","text":"Sharp operator for converting primal 1-forms to primal vector fields.\n\nThis the primal-primal sharp from Hirani 2003, Definition 5.8.1 and Remark 2.7.2.\n\nnote: Note\nA PP-flat is also defined in (Desbrun et al 2005, Definition 7.4) but differs in two ways: Desbrun et al's notation suggests a unit normal vector, whereas the gradient of Hirani's primal-primal interpolation function is not necessarily a unit vector. More importantly, Hirani's vector is a normal to a different face than Desbrun et al's, with further confusion created by the fact that Hirani's Figure 5.7 agrees with Desbrun et al's description rather than his own. That being said, to the best of our knowledge, our implementation is the correct one and agrees with Hirani's description, if not his figure.\n\nSee also: ♭ and ♯_mat, which returns a matrix that encodes this operator.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♯_mat-Tuple{AbstractDeltaDualComplex2D, CombinatorialSpaces.DiscreteExteriorCalculus.DiscreteSharp}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♯_mat","text":"function ♯_mat(s::AbstractDeltaDualComplex2D, DS::DiscreteSharp)\n\nSharpen a 1-form into a vector field.\n\n3 primal-primal methods are supported. See ♯_denominator for the distinction between Hirani's method and and an \"Alternative\" method. Desbrun's definition is selected with DesbrunSharp, and is like Hirani's, save for dividing by the norm twice.\n\nA dual-dual method which uses linear least squares to estimate a vector field is selected with LLSDDSharp.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.DiscreteExteriorCalculus.♯_mat-Tuple{AbstractDeltaDualComplex2D, LLSDDSharp}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.DiscreteExteriorCalculus.♯_mat","text":"function ♯_mat(s::AbstractDeltaDualComplex2D, ::LLSDDSharp)\n\nSharpen a dual 1-form into a DualVectorField, using linear least squares.\n\nUp to floating point error, this method perfectly produces fields which are constant over any triangle in the domain. Assume that the contribution of each half-edge to the value stored on the entire dual edge is proportional to their lengths. Since this least squares method does not perform pre-normalization, the contribution of each half-edge value is proportional to its length on the given triangle. Satisfying the continuous exterior calculus, sharpened vectors are constrained to lie on their triangle (i.e. they are indeed tangent).\n\nIt is not known whether this method has been exploited previously in the DEC literature, or defined in code elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC","text":"The discrete exterior calculus (DEC) with high performance in mind.\n\nThis module provides similar functionality to the DiscreteExteriorCalculus module but uses assumptions about the ACSet mesh structure to greatly improve performance. Some operators, like the exterior derivative are returned as sparse matrices while others, like the wedge product, are instead returned as functions that will compute the product.\n\n\n\n\n\n","category":"module"},{"location":"discrete_exterior_calculus/#Catlab.Theories.:∧-Tuple{HasDeltaSet, DualForm{1, T} where T, EForm{T} where T}","page":"Discrete exterior calculus","title":"Catlab.Theories.:∧","text":"∧(s::HasDeltaSet, α::DualForm{1}, β::SimplexForm{1})\n\nWedge product of a dual 1-form and a primal 1-form.\n\nChain the musical isomorphisms to interpolate the dual 1-form to a primal 1-form. Then use the CombinatorialSpaces version of the Hirani primal-primal weddge (without explicitly dividing by 2.)\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#Catlab.Theories.:∧-Tuple{HasDeltaSet, EForm{T} where T, DualForm{1, T} where T}","page":"Discrete exterior calculus","title":"Catlab.Theories.:∧","text":"∧(s::HasDeltaSet, α::SimplexForm{1}, β::DualForm{1})\n\nWedge product of a primal 1-form and a dual 1-form.\n\nChain the musical isomorphisms to interpolate the dual 1-form to a primal 1-form, using the linear least squares ♯. Then use the CombinatorialSpaces version of the Hirani primal-primal weddge.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.avg_01","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.avg_01","text":"Alias for the averaging operator [`avg₀₁`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.avg_01_mat","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.avg_01_mat","text":"Alias for the averaging matrix [`avg₀₁_mat`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.avg₀₁-Tuple{HasDeltaSet, VForm{T} where T}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.avg₀₁","text":"avg₀₁(s::HasDeltaSet, α::SimplexForm{0})\n\nTurn a 0-form into a 1-form by averaging data stored on the face of an edge.\n\nSee also avg₀₁_mat.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.avg₀₁_mat-Union{Tuple{EmbeddedDeltaDualComplex2D{Bool, float_type}}, Tuple{float_type}} where float_type","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.avg₀₁_mat","text":"Averaging matrix from 0-forms to 1-forms.\n\nGiven a 0-form, this matrix computes a 1-form by taking the mean of value stored on the faces of each edge.\n\nThis matrix can be used to implement a wedge product: (avg₀₁(s)*X) .* Y where X is a 0-form and Y a 1-form, assuming the center of an edge is halfway between its endpoints.\n\nSee also avg₀₁.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.d0_p0_interpolation-Tuple{HasDeltaSet2D}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.d0_p0_interpolation","text":"d0p0interpolation(sd::HasDeltaSet2D; hodge=GeometricHodge())\n\nGenerates a sparse matrix that converts data on dual 0-forms into data on primal 0-forms. This uses the p2_d2_interpolation function as an intermediate step.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_boundary-Tuple{Int64, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_boundary","text":"dec_boundary(n::Int, sd::HasDeltaSet)\n\nReturn the boundary operator (as a matrix) for (n+1)-simplices to (n)-simplices\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_differential-Tuple{Int64, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_differential","text":"dec_differential(n::Int, sd::HasDeltaSet)\n\nReturn the exterior derivative (as a matrix) between n-simplices and (n+1)-simplices\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_dual_derivative-Tuple{Int64, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_dual_derivative","text":"dec_dual_derivative(n::Int, sd::HasDeltaSet)\n\nReturn the dual exterior derivative (as a matrix) between dual n-simplices and dual (n+1)-simplices\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_hodge_star-Tuple{Int64, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_hodge_star","text":"dec_hodge_star(n::Int, sd::HasDeltaSet; hodge=GeometricHodge())\n\nReturn the hodge matrix between n-simplices and dual 'n'-simplices.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_inv_hodge_star-Tuple{Int64, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_inv_hodge_star","text":"dec_inv_hodge_star(n::Int, sd::HasDeltaSet; hodge=GeometricHodge())\n\nReturn the inverse hodge matrix between dual n-simplices and 'n'-simplices.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_wedge_product-Union{Tuple{n}, Tuple{m}, Tuple{Type{Tuple{m, n}}, HasDeltaSet}, Tuple{Type{Tuple{m, n}}, HasDeltaSet, Any}, Tuple{Type{Tuple{m, n}}, HasDeltaSet, Any, Any}, Tuple{Type{Tuple{m, n}}, HasDeltaSet, Any, Any, Any}} where {m, n}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_wedge_product","text":"dec_wedge_product(::Type{Tuple{m,n}}, sd::HasDeltaSet, backend=Val{:CPU}, arr_cons=identity, cast_float=nothing) where {m,n}\n\nReturn a function that computes the wedge product between a primal m-form and a primal n-form, assuming special properties of the mesh.\n\nIt is assumed... ... for the 0-1 wedge product, that the dual vertex on an edge is at the midpoint. ... for the 1-1 wedge product, that the dual mesh simplices are in the default order as returned by the dual complex constructor.\n\nArguments:\n\nTuple{m,n}: the degrees of the differential forms. sd: the simplicial complex. backend=Val{:CPU}: a value-type to select special backend logic, if implemented. arr_cons=identity: a constructor of the desired array type on the appropriate backend e.g. MtlArray. cast_float=nothing: a specific Float type to use e.g. Float32. Otherwise, the type of the first differential form will be used.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_wedge_product_dd-Union{Tuple{n}, Tuple{m}, Tuple{Type{Tuple{m, n}}, HasDeltaSet}} where {m, n}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_wedge_product_dd","text":"dec_wedge_product_dd(::Type{Tuple{m,n}}, sd::HasDeltaSet) where {m,n}\n\nReturn a function that computes the wedge product between a dual m-form and a dual n-form.\n\nThe currently supported dual-dual wedges are 0-1 and 1-0.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_wedge_product_dp-Union{Tuple{n}, Tuple{m}, Tuple{Type{Tuple{m, n}}, HasDeltaSet}} where {m, n}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_wedge_product_dp","text":"dec_wedge_product_dp(::Type{Tuple{m,n}}, sd::HasDeltaSet) where {m,n}\n\nReturn a function that computes the wedge product between a dual m-form and a primal n-form.\n\nIt is assumed... ... for the 1-0 and 0-1 wedge product, that means are barycentric, and performs bilinear interpolation. It is not known if this definition has appeared in the literature or any code.\n\nThe currently supported dual-primal wedges are 0-1, 1-0, and 1-1.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_wedge_product_pd-Union{Tuple{n}, Tuple{m}, Tuple{Type{Tuple{m, n}}, HasDeltaSet}} where {m, n}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_wedge_product_pd","text":"dec_wedge_product_pd(::Type{Tuple{m,n}}, sd::HasDeltaSet) where {m,n}\n\nReturn a function that computes the wedge product between a primal m-form and a dual n-form.\n\nSee dec_wedge_product_dp for assumptions.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.dec_Δ⁻¹-Tuple{Type{Val{0}}, AbstractGeometricMapSeries}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.dec_Δ⁻¹","text":"dec_Δ⁻¹(::Type{Val{0}}, s::AbstractGeometricMapSeries; steps = 3, cycles = 5, alg = cg, μ = 2)\n\nReturn a function that solves the inverse Laplacian problem.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.interior_product_dd-Tuple{Type{Tuple{1, 1}}, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.interior_product_dd","text":"function interior_product_dd(::Type{Tuple{1,1}}, s::SimplicialSets.HasDeltaSet)\n\nGiven a dual 1-form and a dual 1-form, return their interior product as a dual 0-form.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.interior_product_dd-Tuple{Type{Tuple{1, 2}}, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.interior_product_dd","text":"function interior_product_dd(::Type{Tuple{1,1}}, s::SimplicialSets.HasDeltaSet)\n\nGiven a dual 1-form and a dual 2-form, return their interior product as a dual 1-form.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.Δᵈ-Tuple{Type{Val{0}}, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.Δᵈ","text":"function Δᵈ_mat(::Type{Val{0}}, s::SimplicialSets.HasDeltaSet)\n\nReturn a function matrix encoding the dual 0-form Laplacian.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.Δᵈ-Tuple{Type{Val{1}}, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.Δᵈ","text":"function Δᵈ_mat(::Type{Val{2}}, s::SimplicialSets.HasDeltaSet)\n\nReturn a function matrix encoding the dual 1-form Laplacian.\n\n\n\n\n\n","category":"method"},{"location":"discrete_exterior_calculus/#CombinatorialSpaces.FastDEC.ℒ_dd-Tuple{Type{Tuple{1, 1}}, HasDeltaSet}","page":"Discrete exterior calculus","title":"CombinatorialSpaces.FastDEC.ℒ_dd","text":"function ℒ_dd(::Type{Tuple{1,1}}, s::SimplicialSets.HasDeltaSet)\n\nGiven a dual 1-form and a dual 1-form, return their lie derivative as a dual 1-form.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#Combinatorial-maps","page":"Combinatorial maps","title":"Combinatorial maps","text":"","category":"section"},{"location":"combinatorial_maps/","page":"Combinatorial maps","title":"Combinatorial maps","text":"CombinatorialSpaces has incomplete, experimental support for several combinatorial structures used in topological graph theory, such as combinatorial maps and rotation systems. For an introduction to rotation systems and their implementation, see this blog post at the AlgebraicJulia blog.","category":"page"},{"location":"combinatorial_maps/#API-docs","page":"Combinatorial maps","title":"API docs","text":"","category":"section"},{"location":"combinatorial_maps/","page":"Combinatorial maps","title":"Combinatorial maps","text":"Modules = [ CombinatorialSpaces.CombinatorialMaps ]\nPrivate = false","category":"page"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps","text":"Combinatorial maps and related structures, as C-sets.\n\nIn topological graph theory and graph drawing, an embedded graph is a combinatorial structure representing a graph embedded in an (oriented) surface, up to equivalence under (orientation-preserving) homeomorphism. This module defines data structures for rotation systems, combinatorial maps, and other combinatorial objects describing embedded graphs.\n\n\n\n\n\n","category":"module"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.add_corolla!-Tuple{CombinatorialSpaces.CombinatorialMaps.AbstractRotationGraph, Int64}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.add_corolla!","text":"Add corolla to rotation graph, rotation system, or similar structure.\n\nA corolla is a vertex together with its incident half-edges, the number of which is its valence. The rotation on the half-edges is the consecutive one induced by the half-edge part numbers.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.pair_half_edges!-Tuple{CombinatorialSpaces.CombinatorialMaps.AbstractRotationGraph, Any, Any}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.pair_half_edges!","text":"Pair together half-edges into edges.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.trace_edges-Tuple{ACSets.ACSetInterface.ACSet}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.trace_edges","text":"Trace edges of combinatorial map or similar, return a listing of cycles.\n\nUsually the cycles will be pairs of half edges but in a hypermap the cycles can be arbitrary.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.trace_faces-Tuple{ACSets.ACSetInterface.ACSet}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.trace_faces","text":"Trace faces of combinatorial map or similar, returning list of cycles.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.trace_vertices-Tuple{ACSets.ACSetInterface.ACSet}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.trace_vertices","text":"Trace vertices of combinatorial map or similar, returning a list of cycles.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.α-Tuple{ACSets.ACSetInterface.ACSet, Vararg{Any}}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.α","text":"Edge permutation of combinatorial map or similar structure.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.σ-Tuple{ACSets.ACSetInterface.ACSet, Vararg{Any}}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.σ","text":"Vertex permutation of combinatorial map or similar structure.\n\n\n\n\n\n","category":"method"},{"location":"combinatorial_maps/#CombinatorialSpaces.CombinatorialMaps.ϕ-Tuple{ACSets.ACSetInterface.ACSet, Vararg{Any}}","page":"Combinatorial maps","title":"CombinatorialSpaces.CombinatorialMaps.ϕ","text":"Face permutation of combinatorial map or similar structure.\n\n\n\n\n\n","category":"method"},{"location":"euler/#Steady-State-Euler-Equations","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"CombinatorialSpaces provides meshes and discrete operators amenable for solving many types of physics and multi-physics problems. For example, CombinatorialSpaces powers the Decapodes library provides a DSL for generating initial-value problem simulations, such as co-rotating vortices on a sphere governed by Navier-Stokes.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"On this page, we will use CombinatorialSpaces directly to solve a steady-state problem.","category":"page"},{"location":"euler/#Euler-Equations","page":"Steady-State Euler Equations","title":"Euler Equations","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"The Euler equations are a concise model of fluid flow, but this model still demonstrates some interesting differential operators:","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"fracpartial textbfu^flatpartial t + pounds_u textbfu^flat - frac12 textbfd(textbfu^flat(textbfu)) = - frac1rho textbfd p + textbfb^flat","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"See Marsden, Ratiu, and Abraham's \"Manifolds, Tensor Analysis, and Applications\" for an overview in the exterior calculus.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Here, we see an exterior derivative, d, a Lie derivative, ℒ, and an interior product, interior_product.","category":"page"},{"location":"euler/#Discretizing","page":"Steady-State Euler Equations","title":"Discretizing","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Let's examine some particular cases of these equations. For both, we need a mesh and some discrete differential operators.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"using CairoMakie, CombinatorialSpaces, StaticArrays\nusing CombinatorialSpaces.DiscreteExteriorCalculus: eval_constant_primal_form\nusing GeometryBasics: Point3d\nusing LinearAlgebra: norm\n\ns = triangulated_grid(100,100,5,5,Point3d);\nsd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3d}(s);\nsubdivide_duals!(sd, Barycenter());\n\nf = Figure()\nax = CairoMakie.Axis(f[1,1])\nwireframe!(ax, s)\n\nf","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Now that we have our mesh, let's allocate our discrete differential operators:","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"d0 = dec_dual_derivative(0, sd)\nd1 = dec_differential(1, sd);\ns1 = dec_hodge_star(1, sd);\ns2 = dec_hodge_star(2, sd);\nι1 = interior_product_dd(Tuple{1,1}, sd)\nι2 = interior_product_dd(Tuple{1,2}, sd)\nℒ1 = ℒ_dd(Tuple{1,1}, sd);","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"using ACSets\n\nsharp_dd = ♯_mat(sd, LLSDDSharp())\nfunction plot_dvf(sd, X; ls=1f0, title=\"Dual Vector Field\")\n  X♯ = sharp_dd * X\n  # Makie will throw an error if the colorrange end points are not unique:\n  f = Figure()\n  ax = Axis(f[1, 1], title=title)\n  wireframe!(ax, sd, color=:gray95)\n  extX = extrema(norm.(X♯))\n  if (abs(extX[1] - extX[2]) > 1e-4)\n    range = extX\n    scatter!(ax, getindex.(sd[sd[:tri_center], :dual_point],1), getindex.(sd[sd[:tri_center], :dual_point],2), color = norm.(X♯), colorrange=range)\n    Colorbar(f[1,2], limits=range)\n  end\n  arrows!(ax, getindex.(sd[sd[:tri_center], :dual_point],1), getindex.(sd[sd[:tri_center], :dual_point],2), getindex.(X♯,1), getindex.(X♯,2), lengthscale=ls)\n  hidedecorations!(ax)\n  f\nend\n\nsharp_pp = ♯_mat(sd, AltPPSharp())\nfunction plot_vf(sd, X; ls=1f0, title=\"Primal Vector Field\")\n  X♯ = sharp_pp * X\n  # Makie will throw an error if the colorrange end points are not unique:\n  f = Figure()\n  ax = Axis(f[1, 1], title=title)\n  wireframe!(ax, sd, color=:gray95)\n  extX = extrema(norm.(X♯))\n  if (abs(extX[1] - extX[2]) > 1e-4)\n    range = extX\n    scatter!(ax, getindex.(sd[:point],1), getindex.(sd[:point],2), color = norm.(X♯), colorrange=range)\n    Colorbar(f[1,2], limits=range)\n  end\n  arrows!(ax, getindex.(sd[:point],1), getindex.(sd[:point],2), getindex.(X♯,1), getindex.(X♯,2), lengthscale=ls)\n  hidedecorations!(ax)\n  f\nend\n\nfunction plot_dual0form(sd, f0; title=\"Dual 0-form\")\n  ps  = (stack(sd[sd[:tri_center], :dual_point])[[1,2],:])'\n  f = Figure(); ax = CairoMakie.Axis(f[1,1], title=title);\n  if (minimum(f0) ≈ maximum(f0))\n    sct = scatter!(ax, ps)\n  else\n    sct = scatter!(ax, ps,\n        color=f0);\n    Colorbar(f[1,2], sct)\n  end\n  f\nend\n\nfunction boundary_inds(::Type{Val{0}}, s)\n  ∂1_inds = boundary_inds(Val{1}, s)\n  unique(vcat(s[∂1_inds,:∂v0],s[∂1_inds,:∂v1]))\nend\nfunction boundary_inds(::Type{Val{1}}, s)\n  collect(findall(x -> x != 0, boundary(Val{2},s) * fill(1,ntriangles(s))))\nend\nfunction boundary_inds(::Type{Val{2}}, s)\n  ∂1_inds = boundary_inds(Val{1}, s)\n  inds = map([:∂e0, :∂e1, :∂e2]) do esym\n    vcat(incident(s, ∂1_inds, esym)...)\n  end\n  unique(vcat(inds...))\nend","category":"page"},{"location":"euler/#First-Case","page":"Steady-State Euler Equations","title":"First Case","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"In this first case, we will explicitly provide initial values for u. We will solve for pressure and the time derivative of u and check that they are what we expect. Note that we will set the mass budget, b, to 0.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Let's provide a flow field of unit magnitude, static throughout the domain. We want to store this as a 1-form. We can create a 1-form by \"flattening\" a vector field, performing many line integrals to store values on the edges of the mesh. Since we want to store our flow as a \"dual\" 1-form (on the edges of the dual mesh), we can use the Hodge star operator to convert from a primal 1-form to a dual 1-form. Since the values of a 1-form can be unintuitive, we will \"sharpen\" the 1-form back to a vector field when visualizing.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"X♯ = SVector{3,Float64}(1/√2,1/√2,0)\nu = s1 * eval_constant_primal_form(sd, X♯)\n\nplot_dvf(sd, u, title=\"Flow\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Let's look at the self-advection term, in which we take the lie derivative of u along itself, and subtract half of the gradient of its inner product. (See Marsden, Ratiu, and Abraham for a derivation.) Recall that our flow u is static throughout the domain, so we should expect this term to be 0 throughout the interior of the domain, where it is not affected by boundary conditions.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"The Lie derivative encodes how a differential form changes along a vector field. For our case of many parallel streamlines, and in which the magnitude is identical everywhere, we expect such a quantity to be 0. However, when discretizing, we have to make some assumptions about what is happening \"outside\" of the domain, and these assumptions have implications on the data stored on the boundary of the domain. In our discretization, we assume the flow outside the domain is 0. Thus, our Lie derivative along the boundary points inward:","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"lie_u_u = ℒ1(u,u)\n\nplot_dvf(sd, lie_u_u, title=\"Lie Derivative of Flow with Itself\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"selfadv = ℒ1(u,u) - 0.5*d0*ι1(u,u)\n\nplot_dvf(sd, selfadv, title=\"Self-Advection\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Now, let's solve for pressure. We can set up a Poisson problem on the divergence of the self-advection term we computed. Recall that divergence can be computed as star d star, and the Laplacian as d star d star. To solve a Poisson problem, we reverse the order of the operations, and take advantage of the fact that solving the inverse hodge star is equivalent to multiplying by the hodge star.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"div(x) = s2 * d1 * (s1 \\ x);\nsolveΔ(x) = float.(d0) \\ (s1 * (float.(d1) \\ (s2 \\ x)))\n\np = (solveΔ ∘ div)(selfadv)\n\nplot_dual0form(sd, p, title=\"Pressure\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"We see that we have a nonzero pressure of exactly 2 across the interior of the domain.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"dp = d0*p\n\nplot_dvf(sd, dp, title=\"Pressure Gradient\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Based on our initial conditions and the way that we computed pressure, we expect that the time derivative of u should be 0 on the interior of the domain, where it is not affected by boundary conditions.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"∂ₜu = -selfadv - dp;\n\nplot_dvf(sd, ∂ₜu, title=\"Time Derivative\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"We see that we do indeed find zero-vectors throughout the interior of the domain as expected.","category":"page"},{"location":"euler/#Second-Case","page":"Steady-State Euler Equations","title":"Second Case","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"For this second case, we will specify that the time derivative of u is 0. We will assume a constant pressure, and then analyze the steady-states of u. We will again ignore any mass budget, b, and recall the gradient of a constant function (here, pressure) is 0. Recall our formula:","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"fracpartial textbfu^flatpartial t + pounds_u textbfu^flat - frac12 textbfd(textbfu^flat(textbfu)) = - frac1rho textbfd p + textbfb^flat","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"Setting appropriate terms to 0, we have:","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"pounds_u textbfu^flat - frac12 textbfd(textbfu^flat(textbfu)) = 0","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"We already allocated our discrete differential operators. Let us solve.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"println(\"Solving\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"using NLsolve\n\nsteady_flow(u) = ℒ1(u,u) - 0.5*d0*ι1(u,u)\n\nstarting_state = s1 * eval_constant_primal_form(sd, X♯)\nsol = nlsolve(steady_flow, starting_state)\n\nplot_dvf(sd, sol.zero, title=\"Steady State\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"println(\"Solved\")","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"We note that this steady flow of all zero-vectors does indeed satisfy the constraints that we set.","category":"page"},{"location":"euler/#Third-Case","page":"Steady-State Euler Equations","title":"Third Case","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"For this third case, we will again solve for u. However, we will set a Gaussian bubble of pressure at the center of the domain, and use Euler's method to solve Euler's equations.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"fracpartial textbfu^flatpartial t = - pounds_u textbfu^flat + frac12 textbfd(textbfu^flat(textbfu)) - frac1rho textbfd p","category":"page"},{"location":"euler/#Case-3.1:-Euler's-method","page":"Steady-State Euler Equations","title":"Case 3.1: Euler's method","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"center = [50.0, 50.0, 0.0]\ngauss(pnt) = 2 + 50/(√(2*π*10))*ℯ^(-(norm(center-pnt)^2)/(2*10))\np = gauss.(sd[sd[:tri_center], :dual_point])\n\nu = s1 * eval_constant_primal_form(sd, X♯)\ndu = copy(u)\n\nfunction euler_equation!(du,u,p)\n  du .= - ℒ1(u,u) + 0.5*d0*ι1(u,u) - d0*p\nend\n\ndt = 1e-3\nfunction eulers_method()\n  for _ in 0:dt:1\n    euler_equation!(du,u,p)\n    u .+= du * dt\n  end\n  u\nend\n\neulers_method()\n\nplot_dvf(sd, u, title=\"Flow\")","category":"page"},{"location":"euler/#Case-3.2:-Euler's-method-with-Projection","page":"Steady-State Euler Equations","title":"Case 3.2: Euler's method with Projection","text":"","category":"section"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"In Case 3.1, we solved Euler's equation directly using the method of lines. However, we assume that our flow, u, is incompressible. That is, delta u = 0. In our finite updates, we did not check that the self-advection term is divergence free! One way to resolve this discrepancy is the \"Projection method\", and this is intimately related to the Hodge decomposition of the flow. (See the Wikipedia entry on the projection method, for example.) Let's employ this method here.","category":"page"},{"location":"euler/","page":"Steady-State Euler Equations","title":"Steady-State Euler Equations","text":"u = s1 * eval_constant_primal_form(sd, X♯)\ndu = copy(u)\n\ndt = 1e-3\nu_int = zeros(ne(sd))\np_next = zeros(ntriangles(sd))\n\nfunction euler_equation_with_projection!(u)\n  u_int .= u .+ (- ℒ1(u,u) + 0.5*d0*ι1(u,u))*dt\n  p_next .= (solveΔ ∘ div)(u_int/dt)\n  u .= u_int - dt*(d0*p_next)\nend\n\nfunction eulers_method()\n  for _ in 0:dt:1\n    euler_equation_with_projection!(u)\n  end\n  u\nend\n\neulers_method()\n\nplot_dvf(sd, u, title=\"Flow, with Projection Method\")","category":"page"},{"location":"grid_laplace/#Solving-Poisson's-equation-in-multiscale","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"CombinatorialSpaces provides advanced capabilities for working with irregular and complex meshes in up to three dimensions. For a first example of working across meshes of multiple scales at once, we reproduce a 1-D Poisson equation example from Golub and van Loan's \"Matrix Computations\", 11.6.","category":"page"},{"location":"grid_laplace/#Poisson-equation","page":"Solving Poisson's equation in multiscale","title":"Poisson equation","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"In general, the Poisson equation asks for a function on a manifold M with boundary with a fixed Laplacian on the interior, satisfying boundary conditions that may be given in various forms, such as the Dirichlet conditions:","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Delta u = -fumid_partial M = f_0","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"In one dimension, on the interval 01, this specializes to the equation","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"fracd^2udx^2 = -f(x) u(0)=u_0 u(1)=u_1","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"If we subdivide the interval into m congruent pieces of width h=1m, then we get the discretized equations","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"fracu((i-1)h)-2u(ih)+u((i+1)h)h^2approx -f(ih)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"for iin 1ldotsm-1. Since u(0)=u_0u(1)=u_1 are given by the boundary conditions, we can move them to  the right-hand side of the first and last equations, producing the linear system Au=b for ","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"u=u(h)u(2h)ldotsu((m-1)h)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"b=h^2f(h)+u_0h^2f(2h)ldotsh^2f((m-1)h)h^2f(mh)+u_1 text and ","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"A=left(beginmatrix\n2-100cdots0\n-12-10cdots0\n0-12-1cdots0\nvdotsvdots\n0cdots0-12-1\n0cdots00-12\nendmatrixright)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"We are thus led to consider the solution of  Au=b for this tridiagonal A. Tridiagonal systems are easy to solve naively,  of course, but this example also gives a nice illustration of the multi-grid method. The latter proceeds by mixing steps of solution via some iterative solver with approximate corrections obtained on a coarser grid, and works particularly well for this equation where there is a neat division between high-frequency and low-frequency contributors to the solution.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Specifically, we will proceed by restricting discretized functions from a grid of radius h to one of radius 2h and prolonging back from there, by taking the weighted average of values near a coarse-grid point, weighting the point itself double, for restriction, and making the value at a fine-grid point not in the coarse grid average the adjacent coarse values for prolongation. It's interesting to note that restriction after prolongation is not idempotent, but instead smears some heat around away from where it started.","category":"page"},{"location":"grid_laplace/#The-problem-solved-directly-via-multigrid","page":"Solving Poisson's equation in multiscale","title":"The problem solved directly via multigrid","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"using Random # hide\nRandom.seed!(77777) # hide\nusing SparseArrays\nusing LinearAlgebra\nusing CombinatorialSpaces\n\n#The tridiagonal Laplacian discussed above, with single-variable method\n#for power-of-2 grids. \nsparse_square_laplacian(k) = sparse_square_laplacian(2^k-1,1/(2^k))\nfunction sparse_square_laplacian(N,h)\n  A = spzeros(N,N)\n  for i in 1:N\n    A[i,i] = 2\n    if i > 1 A[i,i-1] = -1 end\n    if i < N A[i,i+1] = -1 end\n  end\n  1/h^2 * A\nend\n#The restriction matrix to half as fine a grid.\nfunction sparse_restriction(k)\n  N,M = 2^k-1, 2^(k-1)-1\n  A = spzeros(M,N)\n  for i in 1:M\n    A[i,2i-1:2i+1] = [1,2,1]\n  end\n  1/4*A\nend\n#The prolongation matrix from coarse to fine.\nsparse_prolongation(k) = 2*transpose(sparse_restriction(k))\n\nsparse_square_laplacian(3)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"sparse_restriction(3)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"sparse_prolongation(3)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Here is a function that sets up and runs a v-cycle for the  Poisson problem on a mesh with 2^k+1 points, on all meshes down to 3 points, smoothing using s steps of the Krylov method on each mesh, with a random target vector, and continuing through the entire cycle c times. ","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"In the example, we are solving the Poisson equation on a grid with 2^15+1 points using just 15cdot 7cdot 3  total steps of the conjugate gradient method. ","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"function test_vcycle_1D_gvl(k,s,c)\n  b=rand(2^k-1)\n  N = 2^k-1 \n  md = MultigridData(\n    # Operators\n    reverse([sparse_square_laplacian(k′) for k′ in 1:k]),\n    # Restrictions\n    reverse([sparse_restriction(k′) for k′ in 2:k]),\n    # Prolongations\n    reverse([sparse_prolongation(k′) for k′ in 2:k]),\n    # Steps\n    s)\n  u = zeros(N)\n  norm(md.operators[1] * multigrid_vcycles(u, b, md, c)-b) / norm(b)\nend\ntest_vcycle_1D_gvl(15,7,3)","category":"page"},{"location":"grid_laplace/#Reproducing-the-same-solution-with-CombinatorialSpaces","page":"Solving Poisson's equation in multiscale","title":"Reproducing the same solution with CombinatorialSpaces","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Now we can show how to do the same thing with CombinatorialSpaces. We'll use the same multigrid_vcycles function as before but produce its inputs via types and data structures in CombinatorialSpaces.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"In particular, repeated_subdivisions below produces a sequence of barycentric subdivisions of a delta-set, which is exactly what we need to produce the repeated halvings of the radius of the 1-D mesh in our example.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"using Random # hide\nRandom.seed!(77777) # hide\nusing CombinatorialSpaces\nusing StaticArrays\nusing LinearAlgebra: norm\nusing GeometryBasics: Point3\nconst Point3D = Point3{Float64}","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"We first construct the coarsest stage in the 1-D mesh, with just two vertices and one edge running from (00) to (10).","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"ss = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(ss, 2, point=[(0,0,0),(1,0,0)])\nadd_edge!(ss, 1, 2, edge_orientation=true)\n\nrepeated_subdivisions(4,ss,binary_subdivision_map)[1]","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"The setup function below constructs k subdivision maps and their domains, then computes their Laplacians using CombinatorialSpaces' general capabilities, as well as the prolongation matrices straight from the subdivision maps and the interpolation matrices be renormalizing the transposed prolongations.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"We first construct everything with a sort on the vertices to show that  we get the exact same results as in the first example.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"laplacian(s) = ∇²(0,dualize(s,Barycenter()))\nfunction test_vcycle_1D_cs_setup_sorted(k)\n  b=rand(2^k-1)\n  N = 2^k-1 \n  u = zeros(N)\n\n  sds = reverse(repeated_subdivisions(k,ss,binary_subdivision_map))\n  sses = [sd.domain for sd in sds]\n  sorts = [sort(vertices(ss),by=x->ss[:point][x]) for ss in sses]\n  ls = [laplacian(sses[i])[sorts[i],sorts[i]][2:end-1,2:end-1] for i in eachindex(sses)]\n  ps = transpose.([as_matrix(sds[i])[sorts[i+1],sorts[i]][2:end-1,2:end-1] for i in 1:length(sds)-1])\n  is = transpose.(ps)*1/2\n  u,b,ls,is,ps\nend\nu,b,ls,is,ps = test_vcycle_1D_cs_setup_sorted(3)\nls[1]","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"ps[1]","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Finally, we run a faster and simpler algorithm by avoiding all the sorting. This version makes the truncation of each matrix to ignore the boundary vertices more obvious (and truncates different rows and columns because of skipping the sort.) This is mathematically correct as long as the boundary conditions are zero.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"function test_vcycle_1D_cs_setup(k)\n  b=rand(2^k-1)\n  N = 2^k-1 \n  u = zeros(N)\n\n  sds = reverse(repeated_subdivisions(k,ss,binary_subdivision_map))\n  sses = [sd.domain for sd in sds]\n  ls = [laplacian(sses[i])[3:end,3:end] for i in eachindex(sses)]\n  ps = transpose.([as_matrix(sds[i])[3:end,3:end] for i in 1:length(sds)-1])\n  is = transpose.(ps)*1/2\n  u, b, ls, is, ps\nend\nuu, bb, lls, iis, pps = test_vcycle_1D_cs_setup(15)\nnorm(ls[1] * multigrid_vcycles(u, b, MultigridData(ls, is, ps, 7), 3)-b) / norm(b)","category":"page"},{"location":"grid_laplace/#The-2-D-Poisson-equation","page":"Solving Poisson's equation in multiscale","title":"The 2-D Poisson equation","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Next we consider the two-dimensional Poisson equation Delta u = -F(xy) on the unit square with Dirichlet boundary conditions; for concreteness we'll again focus on the case where the boundary values are zero.","category":"page"},{"location":"grid_laplace/#A-traditional-approach","page":"Solving Poisson's equation in multiscale","title":"A traditional approach","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Divide the unit square 01times 01 into a square mesh with squares of side length h. For each interior point (ihjh), divided differences produce the equation","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"4u(ihjh)-u(ih(j+1)h)-u(ih(j-1)h)-u((i+1)hjh)-u((i-1)hjh) = h^2F(ihjh)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"If we write L(n) for the 1-D discretized Laplacian in n pieces on 01, thus with  diameter h=1n, then it can be shown that, if we index the off-boundary grid points  lexicographically by rows, the matrix encoding all the above equations is given by","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"I_n-1otimes L(n-1) + L(n-1)otimes I_n-1","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"where I_n-1 is the identity matrix of size n-1 and otimes is the Kronecker product. In code, with the Laplacian for the interior of a 5times 5 grid:","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"sym_kron(A,B) = kron(A,B)+kron(B,A)\nsparse_square_laplacian_2D(N,h) = sym_kron(I(N),sparse_square_laplacian(N,h))\nsparse_square_laplacian_2D(k) = sparse_square_laplacian_2D(2^k-1,1/(2^k))\nsparse_square_laplacian_2D(2)","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"To prolong a scalar field from a coarse grid (taking every other row and every other column) to a fine one, the natural rule is to send a coarse grid value to itself,  a value in an even row and odd column or vice versa to the average of its directly  adjacent coarse grid values, and a value in an odd row and column to the average of its four diagonally adjacent coarse grid valus. This produces the prolongation matrix below:","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"sparse_prolongation_2D(k) = kron(sparse_prolongation(k),sparse_prolongation(k))\nsparse_prolongation_2D(3)[1:14,:]","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"We'll impose a Galerkin condition that the prolongation and restriction operators be adjoints of each other up to constants. This leads to the interesting consequence that the restriction operator takens a weighted average of all nine nearby values, including those at the diagonally nearest points, even though those points don't come up in computing second-order divided differences.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"sparse_restriction_2D(k) = transpose(sparse_prolongation_2D(k))/4\nsparse_restriction_2D(3)[1,:]","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Now we can do the same multigrid v-cycles as before, but with the 2-D Laplacian and prolongation operators! Here we'll solve on a grid with about a million points in just a few seconds.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"function test_vcycle_2D_gvl(k,s,c)\n  ls = reverse([sparse_square_laplacian_2D(k′) for k′ in 1:k])\n  is = reverse([sparse_restriction_2D(k′) for k′ in 2:k])\n  ps = reverse([sparse_prolongation_2D(k′) for k′ in 2:k])\n  b = rand(size(ls[1],1))\n  u = zeros(size(ls[1],1))\n  norm(ls[1] * multigrid_vcycles(u, b, MultigridData(ls, is, ps, s), c)-b) / norm(b)\nend\n\ntest_vcycle_2D_gvl(8,20,3)","category":"page"},{"location":"grid_laplace/#Via-combinatorial-spaces","page":"Solving Poisson's equation in multiscale","title":"Via combinatorial spaces","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Below we show how to reconstruct the grid Laplacian using  CombinatorialSpaces.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"using Random # hide\nRandom.seed!(77777) # hide\nusing Krylov\nusing CombinatorialSpaces\nusing GeometryBasics\nusing LinearAlgebra: norm\nPoint2D = Point2{Float64}\n\nlaplacian(ss) = ∇²(0,dualize(ss,Barycenter()))\n\n#Copies of the primal square above in an N x N grid covering unit square in plane\nfunction square_tiling(N)\n  ss = EmbeddedDeltaSet2D{Bool,Point3D}()\n  h = 1/(N-1)\n  points = Point3D.([[i*h,1-j*h,0] for j in 0:N-1 for i in 0:N-1])\n  add_vertices!(ss, N^2, point=points)\n  for i in 1:N^2\n    #vertices not in the left column or bottom row\n    if (i-1)%N != 0 && (i-1) ÷ N < N-1\n      glue_sorted_triangle!(ss, i, i+N-1,i+N)\n    end\n    #vertices not in the right column or bottom row\n    if i %N != 0 && (i-1) ÷ N < N-1\n      glue_sorted_triangle!(ss, i, i+1,i+N)\n    end\n  end\n  orient!(ss)\n  ss\nend\n\n\ninner(N) = vcat([2+k*N:N-1+k*N for k ∈ 1:N-2]...)\ninlap(N) = laplacian(square_tiling(N))[inner(N),inner(N)]\ninlap(5)","category":"page"},{"location":"grid_laplace/#Triangular-grids","page":"Solving Poisson's equation in multiscale","title":"Triangular grids","text":"","category":"section"},{"location":"grid_laplace/#Back-to-heat","page":"Solving Poisson's equation in multiscale","title":"Back to heat","text":"","category":"section"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"Let's solve the Laplacian on a triangular mesh.","category":"page"},{"location":"grid_laplace/","page":"Solving Poisson's equation in multiscale","title":"Solving Poisson's equation in multiscale","text":"using Krylov, CombinatorialSpaces, LinearAlgebra\n\ns = triangulated_grid(1,1,1/4,sqrt(3)/2*1/4,Point3D,false)\nfs = reverse(repeated_subdivisions(4,s,binary_subdivision_map));\nsses = map(fs) do f dom(f) end\npush!(sses,s)\nsds = map(sses) do s dualize(s,Circumcenter()) end\nLs = map(sds) do sd ∇²(0,sd) end\nps = transpose.(as_matrix.(fs))\nrs = transpose.(ps)./4.0 #4 is the biggest row sum that occurs for binary, this is not clearly the correct scaling\n\nu0 = zeros(nv(sds[1]))\nb = Ls[1]*rand(nv(sds[1])) #put into range of the Laplacian for solvability\nu = multigrid_vcycles(u0, b, MultigridData(Ls, rs, ps, 3), 10)\nnorm(Ls[1]*u - b) / norm(b)","category":"page"},{"location":"#CombinatorialSpaces.jl","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"","category":"section"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"This package provides combinatorial models of geometric spaces, such as simplicial sets and combinatorial maps. These \"combinatorial spaces\" are useful in computational physics, computer graphics, and other applications where geometry plays a large role. They are also potentially useful in non-geometric applications, since structures like simplicial sets generalize graphs from binary relations to higher-arity relations.","category":"page"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"Combinatorial spaces, like graphs, are typically C-sets (copresheaves) on some category C. They are implemented here using the general data structures for C-sets offered by Catlab.jl. Thus, this package complements and extends the family of graph data structures shipped with Catlab in the module Catlab.Graphs.","category":"page"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"Current features include:","category":"page"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"delta sets (semi-simplicial sets) in dimensions one and two, optionally oriented and/or embedded in Euclidean space\nconstruction of the dual complex associated with a delta set, via combinatorial and geometric subdivision\ncore operators of the discrete exterior calculus, including the boundary, exterior deriviative, Hodge star, codifferential, and Laplace-Beltrami operators\nexperimental support for rotation systems and combinatorial maps","category":"page"},{"location":"#Installation","page":"CombinatorialSpaces.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"To install this package, open the Julia shell, press ] to enter Pkg mode, and run the command","category":"page"},{"location":"","page":"CombinatorialSpaces.jl","title":"CombinatorialSpaces.jl","text":"(@v1.5) pkg> add CombinatorialSpaces","category":"page"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"using JSServe # hide\nPage(exportable=true, offline=true) # hide","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The two-dimensional embedded delta sets (EmbeddedDeltaSet2D) in CombinatorialSpaces can be converted to and from mesh objects (Mesh) in Meshes.jl. This is useful for interoperation with packages in the JuliaGeometry ecosystem.","category":"page"},{"location":"meshes/#Visualizing-embedded-delta-sets","page":"Meshes","title":"Visualizing embedded delta sets","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The following example shows how to import a mesh from an OBJ file, convert it into an embedded delta set, and render it as a 3D mesh using CairoMakie.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"using FileIO, CairoMakie, CombinatorialSpaces\nset_theme!(resolution=(800, 400))\ncatmesh = FileIO.load(File{format\"OBJ\"}(download(\n  \"https://github.com/JuliaPlots/Makie.jl/raw/master/assets/cat.obj\")))\n\ncatmesh_dset = EmbeddedDeltaSet2D(catmesh)\nmesh(catmesh_dset, shading=false)","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Alterntively, the embedded delta set can be visualized as a wireframe:","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"wireframe(catmesh_dset)","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"We can also construct and plot the dual complex for this mesh:","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"dual = EmbeddedDeltaDualComplex2D{Bool, Float32, Point{3,Float32}}(catmesh_dset)\nsubdivide_duals!(dual, Barycenter())\nwireframe(dual)","category":"page"},{"location":"meshes/#API-docs","page":"Meshes","title":"API docs","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Modules = [ Meshes, MeshInterop ]\nPrivate = false","category":"page"},{"location":"meshes/#CombinatorialSpaces.Meshes.loadmesh-Tuple{Icosphere}","page":"Meshes","title":"CombinatorialSpaces.Meshes.loadmesh","text":"loadmesh(s::Icosphere)\n\nLoad in a icosphere mesh.\n\n\n\n\n\n","category":"method"},{"location":"meshes/#CombinatorialSpaces.Meshes.loadmesh-Tuple{Point_Map}","page":"Meshes","title":"CombinatorialSpaces.Meshes.loadmesh","text":"loadmesh(s::Point_Map)\n\nLoad in a point map describing the connectivity of the toroidal mesh.\n\n\n\n\n\n","category":"method"},{"location":"meshes/#CombinatorialSpaces.Meshes.loadmesh-Tuple{Rectangle_30x10}","page":"Meshes","title":"CombinatorialSpaces.Meshes.loadmesh","text":"loadmesh(s::Rectangle_30x10)\n\nLoad in a rectangular mesh.\n\n\n\n\n\n","category":"method"},{"location":"meshes/#CombinatorialSpaces.Meshes.loadmesh-Tuple{Torus_30x10}","page":"Meshes","title":"CombinatorialSpaces.Meshes.loadmesh","text":"loadmesh(s::Torus_30x10)\n\nLoad in a toroidal mesh.\n\n\n\n\n\n","category":"method"},{"location":"meshes/#CombinatorialSpaces.Meshes.makeSphere-NTuple{7, Any}","page":"Meshes","title":"CombinatorialSpaces.Meshes.makeSphere","text":"makeSphere(minLat, maxLat, dLat, minLong, maxLong, dLong, radius)\n\nConstruct a spherical mesh (inclusively) bounded by the given latitudes and longitudes, discretized at dLat and dLong intervals, at the given radius from Earth's center.\n\nNote that this construction returns a UV-sphere. DEC simulations are more accurate on meshes with (near) equilateral triangles, such as the icospheres available through loadmesh.\n\nWe say that:\n\n90°N is 0\n90°S is 180\nPrime Meridian is 0\n10°W is 355\n\nWe say that:\n\n(x=0,y=0,z=0) is at the center of the sphere\nthe x-axis points toward 0°,0°\nthe y-axis points toward 90°E,0°\nthe z-axis points toward the North Pole\n\nReferences:\n\nList of common coordinate transformations\n\nExamples\n\n# Regular octahedron.\njulia> s, npi, spi = makeSphere(0, 180, 90, 0, 360, 90, 1)\n\n# 72 points along the unit circle on the x-y plane.\njulia> s, npi, spi = makeSphere(90, 90, 0, 0, 360, 5, 1)\n\n# 72 points along the equator at 0km from Earth's surface.\njulia> s, npi, spi = makeSphere(90, 90, 1, 0, 360, 5, 6371)\n\n# TIE-GCM grid at 90km altitude (with no poles,   i.e. a bulbous cylinder).\njulia> s, npi, spi = makeSphere(5, 175, 5, 0, 360, 5, 6371+90)\n\n# TIE-GCM grid at 90km altitude (with South pole, i.e. a bowl).\njulia> s, npi, spi = makeSphere(5, 180, 5, 0, 360, 5, 6371+90)\n\n# TIE-GCM grid at 90km altitude (with poles,      i.e. a sphere).\njulia> s, npi, spi = makeSphere(0, 180, 5, 0, 360, 5, 6371+90)\n\n# The Northern hemisphere of the TIE-GCM grid at 90km altitude.\njulia> s, npi, spi = makeSphere(0, 180, 5, 0, 360, 5, 6371+90)\n\n\n\n\n\n","category":"method"},{"location":"meshes/#CombinatorialSpaces.Meshes.triangulated_grid","page":"Meshes","title":"CombinatorialSpaces.Meshes.triangulated_grid","text":"function triangulated_grid(max_x, max_y, dx, dy, point_type, compress=true)\n\nTriangulate the rectangle [0,maxx] x [0,maxy] by approximately equilateral triangles of width dx and height dy.\n\nIf compress is true (default), then enforce that all rows of points are less than max_x, otherwise, keep dx as is.\n\n\n\n\n\n","category":"function"},{"location":"meshes/#CombinatorialSpaces.MeshInterop","page":"Meshes","title":"CombinatorialSpaces.MeshInterop","text":"Interoperation with mesh files.\n\nThis module enables delta sets to be imported from mesh files supported by MeshIO.jl and for delta sets to be converted to meshes, mainly for the purposes of plotting. Meshes are represented by the GeometryBasics.Mesh type.\n\n\n\n\n\n","category":"module"}]
}
