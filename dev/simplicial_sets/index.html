<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simplicial sets · CombinatorialSpaces.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CombinatorialSpaces.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Simplicial sets</a><ul class="internal"><li><a class="tocitem" href="#Varieties-of-simplicial-stuff"><span>Varieties of simplicial stuff</span></a></li><li><a class="tocitem" href="#Delta-sets"><span>Delta sets</span></a></li><li><a class="tocitem" href="#API-docs"><span>API docs</span></a></li></ul></li><li><a class="tocitem" href="../dual_complexes/">Dual complexes</a></li><li><a class="tocitem" href="../combinatorial_maps/">Combinatorial maps</a></li><li><a class="tocitem" href="../meshes/">Meshes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simplicial sets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simplicial sets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/master/docs/src/simplicial_sets.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simplicial-sets"><a class="docs-heading-anchor" href="#Simplicial-sets">Simplicial sets</a><a id="Simplicial-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-sets" title="Permalink"></a></h1><p>As a core feature, this package provides data structures and algorithms for a flavor of simplicial sets known as <em>semi-simplicial sets</em> or <em>delta sets</em>. The first section explains how delta sets relate to simplicial complexes and other structures. Readers not interested in these distinctions may proceed directly to the next section, on <a href="#Delta-sets">delta sets</a>.</p><h2 id="Varieties-of-simplicial-stuff"><a class="docs-heading-anchor" href="#Varieties-of-simplicial-stuff">Varieties of simplicial stuff</a><a id="Varieties-of-simplicial-stuff-1"></a><a class="docs-heading-anchor-permalink" href="#Varieties-of-simplicial-stuff" title="Permalink"></a></h2><p>A wide, possibly bewildering variety of concepts fall under the heading of &quot;simplicial stuff,&quot; including:</p><ul><li>simplicial complexes</li><li>abstract simplicial complexes</li><li>simplicial sets</li><li>semi-simplicial sets, aka delta sets</li><li>augmented simplicial sets</li><li>symmetric (simplicial) sets</li></ul><p>The most familiar of these are <a href="https://en.wikipedia.org/wiki/Simplicial_complex">simplicial complexes</a>: coherent collections of <span>$n$</span>-simplices of different dimensions <span>$n$</span> embedded in an ambient Euclidean space. A simplicial complex may include points <span>$(n=0)$</span>, line segments <span>$(n=1)$</span>, triangles <span>$(n=2)$</span>, tetrahedra <span>$(n=3)$</span>, and higher-dimensional simplices. Of the structures listed here, only simplicial complexes are geometrical objects. All of the others can be seen as combinatorial abstractions of simplicial complexes.</p><p><a href="https://en.wikipedia.org/wiki/Abstract_simplicial_complex">Abstract simplicial complexes</a> are the oldest and most obvious abstraction of simplicial complexes, but nowadays mathematicians tend to prefer simplicial sets, which enjoy excellent algebraic properties. A <a href="https://en.wikipedia.org/wiki/Simplicial_set">simplicial set</a> <span>$X$</span> consists of sets <span>$X_n$</span>, for <span>$n \geq 0$</span>, of abstract <span>$n$</span>-simplices whose <span>$n+1$</span> different faces are ordered and hence can be numerically indexed, via the <em>face maps</em>.</p><p>In this package, we implement a variant of simplicial sets called <a href="https://ncatlab.org/nlab/show/semi-simplicial+set">semi-simplicial sets</a>, or <a href="https://en.wikipedia.org/wiki/Delta_set">delta sets</a> for short. The difference is that delta sets contain only the face maps, whereas simplicial sets also contain <em>degeneracy maps</em>. The main effect of the degeneracy maps is to enlarge the space of simplicial morphisms by allowing simplices to be &quot;collapsed&quot; onto lower-dimensional ones. Degeneracy maps have their pros and cons, and in the future we will likely provide simplicial sets as well as semi-simplicial ones. For more details, the <a href="https://arxiv.org/abs/0809.4221">paper by Greg Friedman</a> is an excellent illustrated introduction to semi-simplicial and simplicial sets.</p><p>Simplicial sets generalize graphs from one dimension to higher dimensions. The following table gives the precise correspondence between different flavors of simplicial stuff and graphs.</p><table><tr><th style="text-align: right">1-dimensional</th><th style="text-align: right"><span>$n$</span>-dimensional</th></tr><tr><td style="text-align: right">straight-line embedded graph</td><td style="text-align: right">simplicial complex</td></tr><tr><td style="text-align: right">simple graph</td><td style="text-align: right">abstract simplicial complex</td></tr><tr><td style="text-align: right">graph</td><td style="text-align: right">semi-simplicial set</td></tr><tr><td style="text-align: right">reflexive graph</td><td style="text-align: right">simplicial set</td></tr><tr><td style="text-align: right">symmetric graph</td><td style="text-align: right">symmetric semi-simplicial set</td></tr><tr><td style="text-align: right">symmetric reflexive graph</td><td style="text-align: right">symmetric simplicial set</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this table, as in this package and the rest of the AlgebraicJulia  ecosystem, a <em>graph</em> without qualification is always a category theorist&#39;s graph (a directed multigraph), not a simple graph (an undirected graph with no self-loops or multiple edges).</p></div></div><h3 id="Ordered-faces-in-geometric-applications"><a class="docs-heading-anchor" href="#Ordered-faces-in-geometric-applications">Ordered faces in geometric applications</a><a id="Ordered-faces-in-geometric-applications-1"></a><a class="docs-heading-anchor-permalink" href="#Ordered-faces-in-geometric-applications" title="Permalink"></a></h3><p>That the faces of each simplex in a simplicial set are ordered is convenient for many purposes but may seem problematic for geometric applications, where the faces usually regarded as unordered.</p><p>One solution to this problem would be to use <a href="https://ncatlab.org/nlab/show/symmetric+set">symmetric simplicial sets</a>, which are simplicial sets <span>$X$</span> equipped with an action of the symmetric group <span>$S_{n+1}$</span> on the <span>$n$</span>-simplices <span>$X_n$</span>, for every <span>$n$</span>. This is computationally inconvenient because every &quot;unordered <span>$n$</span>-simplex&quot; is then really an equivalence class of <span>$(n+1)!$</span> different <span>$n$</span>-simplices, a number that grows rapidly with <span>$n$</span>. At this time, symmetric simplicial sets of dimension greater than 1 are not implemented in this package.</p><p>To simulate unordered simplicial sets, we instead adopt the convention of a choosing the representative of the equivalence class that orders the vertices of the simplex according to the integer IDs of the vertices. The simplicial set then &quot;presents&quot; a symmetric simplicial set in a canonical way. Indeed, the <a href="https://ncatlab.org/nlab/show/simplicial+complex#vsSSet">standard method</a> of converting an abstract simplicial complex to a simplicial set is to pick a total ordering of its vertices. When following this convention, use the functions <a href="#CombinatorialSpaces.SimplicialSets.add_sorted_edge!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64}"><code>add_sorted_edge!</code></a> and <a href="#CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>glue_sorted_triangle!</code></a>, which automatically sort their inputs to ensure that the ordering condition is satisfied, rather than the functions <code>add_edge!</code> and <a href="#CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>glue_triangle!</code></a>.</p><h2 id="Delta-sets"><a class="docs-heading-anchor" href="#Delta-sets">Delta sets</a><a id="Delta-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Delta-sets" title="Permalink"></a></h2><p>A <em>delta set</em> <span>$X$</span> is a family of sets <span>$X_n$</span> for <span>$n = 0,1,2,\dots$</span>, called the <em><span>$n$</span>-simplices</em>, together with functions</p><p class="math-container">\[X(\partial_n^i): X_n \to X_{n-1}, \qquad n \geq 1, \quad i=0,1,\dots,n,\]</p><p>called the <em>face maps</em>, which must satisfy the <em>semi-simplicial identities</em></p><p class="math-container">\[X(\partial_{n+1}^i) \cdot X(\partial_n^j)
  = X(\partial_{n+1}^{j+1}) \cdot X(\partial_n^i): X_{n+1} \to X_{n-1},
  \qquad 0 \leq i \leq j \leq n.\]</p><p>The function <span>$X(\partial_n^i): X_n \to X_{n-1}$</span> gives the face of an <span>$n$</span>-simplex that is opposite its <span>$i$</span>-th vertex. The semi-simplicial identities then ensure that the faces of each <span>$n$</span>-simplex fit together properly, for example, that the edges of a 2-simplex actually form a triangle.</p><p>In our implementation, the generic function <a href="#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>∂</code></a> supplies all the face maps of a delta set. Specifically, the function call <code>∂(i, n, x, k)</code> gives the <code>i</code>-th face of the <code>n</code>-simplex in the delta set <code>x</code> with index <code>k</code>, and the call <code>∂(i, n, x)</code> gives the <code>i</code>-faces of all <code>n</code>-simplices in the delta set <code>x</code>, which is a vector of integers.</p><p>A finite delta set—the only kind supported here—has no simplices above a certain dimension. For any fixed <span>$N$</span>, an <em><span>$N$</span>-dimensional delta set</em> is a delta set <span>$X$</span> such that <span>$X_n = \emptyset$</span> for <span>$n &gt; N$</span>. CombinatorialSpaces provides dedicated data structures for delta sets of a given dimension.</p><h3 id="D-delta-sets"><a class="docs-heading-anchor" href="#D-delta-sets">1D delta sets</a><a id="D-delta-sets-1"></a><a class="docs-heading-anchor-permalink" href="#D-delta-sets" title="Permalink"></a></h3><p>Since a one-dimensional delta set is the same thing as a graph, the type <a href="#CombinatorialSpaces.SimplicialSets.DeltaSet1D"><code>DeltaSet1D</code></a> has the same methods as the type <code>Graph</code> in <a href="https://algebraicjulia.github.io/Catlab.jl/stable/apis/graphs/"><code>Catlab.Graphs</code></a>, which should be consulted for further documentation.</p><pre><code class="language-julia hljs">dset = DeltaSet1D()
add_vertices!(dset, 4)
add_edges!(dset, [1,2,2], [2,3,4])
dset</code></pre><div class="c-set">
<span class="c-set-summary">CSet with elements V = 1:4, E = 1:3</span>
<table>
  <tr class = "header headerLastRow">
    <th class = "rowNumber">E</th>
    <th style = "text-align: right;">src</th>
    <th style = "text-align: right;">tgt</th>
  </tr>
  <tr>
    <td class = "rowNumber">1</td>
    <td style = "text-align: right;">1</td>
    <td style = "text-align: right;">2</td>
  </tr>
  <tr>
    <td class = "rowNumber">2</td>
    <td style = "text-align: right;">2</td>
    <td style = "text-align: right;">3</td>
  </tr>
  <tr>
    <td class = "rowNumber">3</td>
    <td style = "text-align: right;">2</td>
    <td style = "text-align: right;">4</td>
  </tr>
</table>
</div>
<p>One potentially confusing point is that the face map <span>$\partial_1^0$</span> gives the target vertex (the vertex of an edge opposite vertex 0), while the face map <span>$\partial_1^1$</span> gives the source vertex (the vertex of an edge opposite vertex 1).</p><pre><code class="language-julia hljs">@assert ∂(1,0,dset) == tgt(dset)
@assert ∂(1,1,dset) == src(dset)</code></pre><h3 id="D-delta-sets-2"><a class="docs-heading-anchor" href="#D-delta-sets-2">2D delta sets</a><a class="docs-heading-anchor-permalink" href="#D-delta-sets-2" title="Permalink"></a></h3><p>Two-dimensional delta sets, comprised of vertices, edges, and triangles, are supplied by the type <a href="#CombinatorialSpaces.SimplicialSets.DeltaSet2D"><code>DeltaSet2D</code></a>. There are two ways to add triangles to a delta set. If appropriately arranged edges have already been added, a triangle having those edges as boundary can be added using the <a href="#CombinatorialSpaces.SimplicialSets.add_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>add_triangle!</code></a> function. However, it often more convenient to use the <a href="#CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>glue_triangle!</code></a> function, which takes vertices rather than edges as arguments, creating any boundary edges that do not already exist.</p><p>For example, the following 2D delta set has the shape of a triangulated commutative square.</p><pre><code class="language-julia hljs">dset = DeltaSet2D()
add_vertices!(dset, 4)
glue_triangle!(dset, 1, 2, 3)
glue_triangle!(dset, 1, 4, 3)
dset</code></pre><div class="c-set">
<span class="c-set-summary">CSet with elements V = 1:4, E = 1:5, Tri = 1:2</span>
<table>
  <tr class = "header headerLastRow">
    <th class = "rowNumber">E</th>
    <th style = "text-align: right;">src</th>
    <th style = "text-align: right;">tgt</th>
  </tr>
  <tr>
    <td class = "rowNumber">1</td>
    <td style = "text-align: right;">1</td>
    <td style = "text-align: right;">2</td>
  </tr>
  <tr>
    <td class = "rowNumber">2</td>
    <td style = "text-align: right;">2</td>
    <td style = "text-align: right;">3</td>
  </tr>
  <tr>
    <td class = "rowNumber">3</td>
    <td style = "text-align: right;">1</td>
    <td style = "text-align: right;">3</td>
  </tr>
  <tr>
    <td class = "rowNumber">4</td>
    <td style = "text-align: right;">1</td>
    <td style = "text-align: right;">4</td>
  </tr>
  <tr>
    <td class = "rowNumber">5</td>
    <td style = "text-align: right;">4</td>
    <td style = "text-align: right;">3</td>
  </tr>
</table>
<table>
  <tr class = "header headerLastRow">
    <th class = "rowNumber">Tri</th>
    <th style = "text-align: right;">∂e0</th>
    <th style = "text-align: right;">∂e1</th>
    <th style = "text-align: right;">∂e2</th>
  </tr>
  <tr>
    <td class = "rowNumber">1</td>
    <td style = "text-align: right;">2</td>
    <td style = "text-align: right;">3</td>
    <td style = "text-align: right;">1</td>
  </tr>
  <tr>
    <td class = "rowNumber">2</td>
    <td style = "text-align: right;">5</td>
    <td style = "text-align: right;">3</td>
    <td style = "text-align: right;">4</td>
  </tr>
</table>
</div>
<p>As the table above illustrates, only the edges of each triangle are explicitly stored. The vertices of a triangle can be accessed using the function <a href="#CombinatorialSpaces.SimplicialSets.triangle_vertices-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>triangle_vertices</code></a>. The correctness of this function depends on the semi-simplicial identities.</p><pre><code class="language-julia hljs">map(triangles(dset)) do t
  triangle_vertices(dset, t)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{StaticArrays.SVector{3, Int64}}:
 [1, 2, 3]
 [1, 4, 3]</code></pre><h2 id="API-docs"><a class="docs-heading-anchor" href="#API-docs">API docs</a><a id="API-docs-1"></a><a class="docs-heading-anchor-permalink" href="#API-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets" href="#CombinatorialSpaces.SimplicialSets"><code>CombinatorialSpaces.SimplicialSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Simplicial sets in one, two, and three dimensions.</p><p>For the time being, this module provides data structures only for <a href="https://en.wikipedia.org/wiki/Delta_set">delta sets</a>, also known as <a href="https://ncatlab.org/nlab/show/semi-simplicial+set">semi-simplicial sets</a>. These include the face maps but not the degeneracy maps of a simplicial set. In the future we may add support for simplicial sets. The analogy to keep in mind is that graphs are to semi-simpicial sets as reflexive graphs are to simplicial sets.</p><p>Also provided are the fundamental operators on simplicial sets used in virtually all geometric applications, namely the boundary and coboundary (discrete exterior derivative). For additional operators, see the <code>DiscreteExteriorCalculus</code> module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.AbstractDeltaSet1D" href="#CombinatorialSpaces.SimplicialSets.AbstractDeltaSet1D"><code>CombinatorialSpaces.SimplicialSets.AbstractDeltaSet1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for 1D delta sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.AbstractDeltaSet2D" href="#CombinatorialSpaces.SimplicialSets.AbstractDeltaSet2D"><code>CombinatorialSpaces.SimplicialSets.AbstractDeltaSet2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for 2D delta sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L146-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.DeltaSet1D" href="#CombinatorialSpaces.SimplicialSets.DeltaSet1D"><code>CombinatorialSpaces.SimplicialSets.DeltaSet1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A one-dimensional delta set, aka semi-simplicial set.</p><p>Delta sets in 1D are the same as graphs, and this type is just an alias for <code>Graph</code>. The face maps <a href="#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>∂</code></a> translates the graph-theoretic terminology into simplicial terminology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.DeltaSet2D" href="#CombinatorialSpaces.SimplicialSets.DeltaSet2D"><code>CombinatorialSpaces.SimplicialSets.DeltaSet2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A 2D delta set, aka semi-simplicial set.</p><p>The triangles in a semi-simpicial set can be interpreted in several ways. Geometrically, they are triangles (2-simplices) whose three edges are directed according to a specific pattern, determined by the ordering of the vertices or equivalently by the simplicial identities. This geometric perspective is present through the subpart names <code>∂e0</code>, <code>∂e1</code>, and <code>∂e2</code> and through the boundary map <a href="#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>∂</code></a>. Alternatively, the triangle can be interpreted as a higher-dimensional link or morphism, going from two edges in sequence (which might be called <code>src2_first</code> and <code>src2_last</code>) to a transitive edge (say <code>tgt2</code>). This is the shape of the binary composition operation in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.E" href="#CombinatorialSpaces.SimplicialSets.E"><code>CombinatorialSpaces.SimplicialSets.E</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Edge in simplicial set: alias for <code>Simplex{1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L295-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet1D" href="#CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet1D"><code>CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A one-dimensional, embedded, oriented delta set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D" href="#CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D"><code>CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A two-dimensional, embedded, oriented delta set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L272-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.OrientedDeltaSet1D" href="#CombinatorialSpaces.SimplicialSets.OrientedDeltaSet1D"><code>CombinatorialSpaces.SimplicialSets.OrientedDeltaSet1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A one-dimensional oriented delta set.</p><p>Edges are oriented from source to target when <code>edge_orientation</code> is true/positive and from target to source when it is false/negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.OrientedDeltaSet2D" href="#CombinatorialSpaces.SimplicialSets.OrientedDeltaSet2D"><code>CombinatorialSpaces.SimplicialSets.OrientedDeltaSet2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A two-dimensional oriented delta set.</p><p>Triangles are ordered in the cyclic order <span>$(0,1,2)$</span> when <code>tri_orientation</code> is true/positive and in the reverse order when it is false/negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.Simplex" href="#CombinatorialSpaces.SimplicialSets.Simplex"><code>CombinatorialSpaces.SimplicialSets.Simplex</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for simplex or simplices of dimension <code>n</code>.</p><p>See also: <a href="#CombinatorialSpaces.SimplicialSets.V"><code>V</code></a>, <a href="#CombinatorialSpaces.SimplicialSets.E"><code>E</code></a>, <a href="#CombinatorialSpaces.SimplicialSets.Tri"><code>Tri</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.SimplexChain" href="#CombinatorialSpaces.SimplicialSets.SimplexChain"><code>CombinatorialSpaces.SimplicialSets.SimplexChain</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for chain of oriented simplices of dimension <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L303-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.SimplexForm" href="#CombinatorialSpaces.SimplicialSets.SimplexForm"><code>CombinatorialSpaces.SimplicialSets.SimplexForm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for discrete form, aka cochain, in simplicial set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L311-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.Tri" href="#CombinatorialSpaces.SimplicialSets.Tri"><code>CombinatorialSpaces.SimplicialSets.Tri</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Triangle in simplicial set: alias for <code>Simplex{2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L299-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.V" href="#CombinatorialSpaces.SimplicialSets.V"><code>CombinatorialSpaces.SimplicialSets.V</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Vertex in simplicial set: alias for <code>Simplex{0}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L291-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.add_sorted_edge!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64}" href="#CombinatorialSpaces.SimplicialSets.add_sorted_edge!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64}"><code>CombinatorialSpaces.SimplicialSets.add_sorted_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add edge to simplicial set, respecting the order of the vertex IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.add_sorted_edges!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, AbstractVector{Int64}, AbstractVector{Int64}}" href="#CombinatorialSpaces.SimplicialSets.add_sorted_edges!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, AbstractVector{Int64}, AbstractVector{Int64}}"><code>CombinatorialSpaces.SimplicialSets.add_sorted_edges!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add edges to simplicial set, respecting the order of the vertex IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L74-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.add_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}" href="#CombinatorialSpaces.SimplicialSets.add_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>CombinatorialSpaces.SimplicialSets.add_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a triangle (2-simplex) to a simplicial set, given its boundary edges.</p><p>In the arguments to this function, the boundary edges have the order <span>$0 → 1$</span>, <span>$1 → 2$</span>, <span>$0 → 2$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This low-level function does not check the simplicial identities. It is your responsibility to ensure they are satisfied. By contrast, triangles added using the function <a href="#CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>glue_triangle!</code></a> always satisfy the simplicial identities, by construction. Thus it is often easier to use this function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L193-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.boundary" href="#CombinatorialSpaces.SimplicialSets.boundary"><code>CombinatorialSpaces.SimplicialSets.boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for the face map and boundary operator <a href="#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>∂</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L365-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.coboundary" href="#CombinatorialSpaces.SimplicialSets.coboundary"><code>CombinatorialSpaces.SimplicialSets.coboundary</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for the coboundary operator <a href="#CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, SimplexForm{n, T, V} where {T, V&lt;:AbstractVector{T}}}} where n"><code>d</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L381-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, SimplexForm{n, T, V} where {T, V&lt;:AbstractVector{T}}}} where n" href="#CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, SimplexForm{n, T, V} where {T, V&lt;:AbstractVector{T}}}} where n"><code>CombinatorialSpaces.SimplicialSets.d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The discrete exterior derivative, aka the coboundary operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L369-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.edge_vertices-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.edge_vertices-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.edge_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Boundary vertices of an edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.exterior_derivative" href="#CombinatorialSpaces.SimplicialSets.exterior_derivative"><code>CombinatorialSpaces.SimplicialSets.exterior_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for the discrete exterior derivative <a href="#CombinatorialSpaces.SimplicialSets.d-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, SimplexForm{n, T, V} where {T, V&lt;:AbstractVector{T}}}} where n"><code>d</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L385-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}" href="#CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>CombinatorialSpaces.SimplicialSets.glue_sorted_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Glue a triangle onto a simplicial set, respecting the order of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L223-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}" href="#CombinatorialSpaces.SimplicialSets.glue_triangle!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Int64, Int64, Int64}"><code>CombinatorialSpaces.SimplicialSets.glue_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Glue a triangle onto a simplicial set, given its boundary vertices.</p><p>If a needed edge between two vertices exists, it is reused (hence the &quot;gluing&quot;); otherwise, it is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.nsimplices-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#CombinatorialSpaces.SimplicialSets.nsimplices-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>CombinatorialSpaces.SimplicialSets.nsimplices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of simplices of given dimension in a simplicial set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L323-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.orient!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}}" href="#CombinatorialSpaces.SimplicialSets.orient!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}}"><code>CombinatorialSpaces.SimplicialSets.orient!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Consistently orient simplices in a simplicial set, if possible.</p><p>Two simplices with a common face are <em>consistently oriented</em> if they induce opposite orientations on the shared face. This function attempts to consistently orient all simplices of a given dimension and returns whether this has been achieved. Each connected component is oriently independently using the helper function <a href="#CombinatorialSpaces.SimplicialSets.orient_component!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}, Int64, Vararg{Any, N} where N}"><code>orient_component!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L426-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.orient_component!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}, Int64, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.orient_component!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}, Int64, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.orient_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Consistently orient simplices in the same connected component, if possible.</p><p>Given an <span>$n$</span>-simplex and a choice of orientation for it, this function attempts to consistently orient all <span>$n$</span>-simplices that may be reached from it by traversing <span>$(n-1)$</span>-faces. The traversal is depth-first. If a consistent orientation is possible, the function returns <code>true</code> and the orientations are assigned; otherwise, it returns <code>false</code> and no orientations are changed.</p><p>If the simplicial set is not connected, the function <a href="#CombinatorialSpaces.SimplicialSets.orient!-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, AD, Ts} where {AD&lt;:(Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:V, :E), (:src, :tgt), (2, 2), (1, 1)}, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), Ts&lt;:Tuple}}"><code>orient!</code></a> may be more convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L458-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.orientation-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n" href="#CombinatorialSpaces.SimplicialSets.orientation-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>CombinatorialSpaces.SimplicialSets.orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Orientation of simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L389-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.point-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.point-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Point associated with vertex of complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L122-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.set_orientation!-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.set_orientation!-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.set_orientation!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set orientation of simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L403-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.simplices-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#CombinatorialSpaces.SimplicialSets.simplices-Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>CombinatorialSpaces.SimplicialSets.simplices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplices of given dimension in a simplicial set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L319-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.triangle_edges-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.triangle_edges-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.triangle_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Boundary edges of a triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L177-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.triangle_vertices-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}" href="#CombinatorialSpaces.SimplicialSets.triangle_vertices-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Vararg{Any, N} where N}"><code>CombinatorialSpaces.SimplicialSets.triangle_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Boundary vertices of a triangle.</p><p>This accessor assumes that the simplicial identities hold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.volume-Tuple{Any}" href="#CombinatorialSpaces.SimplicialSets.volume-Tuple{Any}"><code>CombinatorialSpaces.SimplicialSets.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><p><span>$n$</span>-dimensional volume of <span>$n$</span>-simplex spanned by given <span>$n+1$</span> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L510-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.volume-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}, Vararg{Any, N} where N}} where n" href="#CombinatorialSpaces.SimplicialSets.volume-Union{Tuple{n}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}, Vararg{Any, N} where N}} where n"><code>CombinatorialSpaces.SimplicialSets.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><p><span>$n$</span>-dimensional volume of <span>$n$</span>-simplex in an embedded simplicial set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L408-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n" href="#CombinatorialSpaces.SimplicialSets.∂-Union{Tuple{n}, Tuple{Int64, Catlab.CSetDataStructures.AbstractAttributedCSet, Simplex{n, N, Data} where {N, Data}}} where n"><code>CombinatorialSpaces.SimplicialSets.∂</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Face map and boundary operator on simplicial sets.</p><p>Given numbers <code>n</code> and <code>0 &lt;= i &lt;= n</code> and a simplicial set of dimension at least <code>n</code>, the <code>i</code>th face map is implemented by the call</p><pre><code class="language-julia hljs">∂(n, i, s, ...)</code></pre><p>The boundary operator on <code>n</code>-faces and <code>n</code>-chains is implemented by the call</p><pre><code class="language-julia hljs">∂(n, s, ...)</code></pre><p>Note that the face map returns <em>simplices</em>, while the boundary operator returns <em>chains</em> (vectors in the free vector space spanned by oriented simplices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/CombinatorialSpaces.jl/blob/26096fd9e5b44faa50647d1f6bf408a1998a9327/src/SimplicialSets.jl#L327-L345">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../dual_complexes/">Dual complexes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Thursday 22 July 2021 20:47">Thursday 22 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
