# Mesh Decomposition

```{julia}
using CombinatorialSpaces
using GeometryBasics: Point3d
using LinearAlgebra: norm
using CairoMakie
using Catlab

s = triangulated_grid(100,100,15,15,Point3d);
sd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3d}(s);
subdivide_duals!(sd, Barycenter());

f = Figure()
ax = CairoMakie.Axis(f[1,1])
wireframe!(ax, s)

f
```

```{julia}
function draw(mesh::EmbeddedDeltaSet2D; color=:blue)
  f = Figure()
  ax = CairoMakie.Axis(f[1,1])
  wireframe!(ax, s, color=color)
  return f, ax
end

function draw(submesh::Subobject; color=:orange)
  ϕ = hom(submesh)
  f, ax = draw(codom(ϕ))
  wireframe!(ax, dom(ϕ), color=color)
  f
end

function draw(cover::Vector{T}; color=:orange) where T <: Subobject
  f = Figure()
  n = length(cover)
  for i in 1:n
    for j in i:n
      ax = CairoMakie.Axis(f[i,j])
      ui,uj = cover[i], cover[j]
      ϕ = hom(meet(ui,uj))
      wireframe!(ax, codom(ϕ), color=:blue)
      wireframe!(ax, dom(ϕ), color=color)
    end
  end
  f
end
```

```{julia}
quadrants(x) = Int(x[1] > 50) + 2*Int(x[2] > 50)

function cover_mesh(partition_function, s)
  vertex_partition = map(partition_function, s[:point])
  parts = map(unique(vertex_partition)) do p
    vp = findall(i->i==p, vertex_partition)
    sp = non(negate(Subobject(s; V=vp)))
  end
  return parts
end
quads = cover_mesh(quadrants, s)
q = quads[1]
draw(q)
```
```{julia}
draw(quads[2])
```

```{julia}
q = join(quads[1], quads[3])
draw(q)
```

```{julia}
draw(meet(quads[1], quads[2]))
```

```{julia}
draw(quads)
```

```{julia}
using Catlab.FreeDiagrams
function nerve(cover::Vector{T}) where T <: Subobject
  n = length(cover)
  map(1:n) do i
    map(i:n) do j
      ui,uj = cover[i], cover[j]
      uij = meet(ui,uj)
      (uij, i, j)
    end
  end |> Iterators.flatten
end
D = nerve(quads)
```

```{julia}
function finsetdiagram(cover; object=:V)
  n = length(cover)
  u1 = cover[1]
  f = hom(u1)
  X = codom(f)
  ObT = FinSet
  HomT = Catlab.CategoricalAlgebra.FinFunction
  homs = [(hom(cover[i]).components[object], i+1, 1) for i in 1:n]
  opens = dom.(hom.(cover))
  obs = [X]
  append!(obs, opens)
  obs = FinSet.(nparts.(obs, object))
  # @show obs
  # edge_homs = map(homs) do (ui, s, t)
  #   println("$s --> $t = $ui")
  # end
  diag = FreeDiagram(obs, homs)
end

diag = finsetdiagram(quads)
```

```{julia}
using Catlab.Sheaves: FVect
import Catlab.Sheaves: pullback_matrix

function vectdiagram(diag)
  obs = diag[:ob]
  homs = map(enumerate(diag[edges(diag), :hom])) do (e, f)
    (pullback_matrix(f), diag[e, :src], diag[e,:tgt])
  end
  @show homs
  FreeDiagram(obs, homs)
end
vectdiagram(diag)
```

```{julia}
function freediagram(cover; nerve_dimension=0)
  nerve_dimension >= 0 || error("nerve_dimension must be nonnegative")
  n = length(cover)
  u1 = cover[1]
  f = hom(u1)
  X = codom(f)
  ObT = typeof(X)
  HomT = typeof(f)
  homs = [(hom(cover[i]), i+1, 1) for i in 1:n]
  opens = dom.(hom.(cover))
  obs = [X]
  append!(obs, opens)
  if nerve_dimension == 1
    D = nerve(cover)
    edge_homs = map(D) do (uij, i, j)
      f = hom(uij)
      f.codom = obs[i+1]
      return (f, i+1, j+1)
    end
    for e in edge_homs
      @show e[2], e[3], nv(dom(e[1])), nv(codom(e[1]))
    end
    append!(homs, edge_homs)
  end
  nerve_dimension < 2 || error("nerve_dimension must <= 1")
  diag = FreeDiagram{ObT,HomT}(obs, homs)
end

freediagram(quads)
freediagram(quads, nerve_dimension=true)
```