# Mesh Decomposition

```{julia}
using CombinatorialSpaces
using GeometryBasics: Point3d
using LinearAlgebra: norm
using CairoMakie
using Catlab

```

```{julia}
function draw(mesh; color=:blue)
  f = Figure()
  ax = CairoMakie.Axis(f[1,1])
  draw!(ax, mesh, color=color)
  return f
end

function draw!(ax, mesh::EmbeddedDeltaDualComplex1D; color=:blue)
  ax = scatter!(ax, mesh[:point], color=color)
end

function draw!(ax, mesh::Union{EmbeddedDeltaSet2D,EmbeddedDeltaDualComplex2D}; color=:blue)
  wireframe!(ax, mesh, color=color)
  return ax
end

function draw!(ax, submesh::Subobject; color=:orange)
  ϕ = hom(submesh)
  @show nparts(dom(ϕ), :V)
  @show nparts(codom(ϕ), :V)
  draw!(ax, codom(ϕ),color=color)
  draw!(ax, dom(ϕ), color=:orange)
end


function draw(cover::Vector{T}; color=:blue) where T <: Subobject
  f = Figure()
  n = length(cover)
  for i in 1:n
    for j in i:n
      ax = CairoMakie.Axis(f[i,j])
      ui,uj = cover[i], cover[j]
      # ϕ = hom(meet(ui,uj))
      # draw!(ax, codom(ϕ), color=:blue)
      # draw!(ax, dom(ϕ), color=color)
      draw!(ax, meet(ui,uj), color=color)
    end
  end
  f
end
```
```{julia}
s = triangulated_grid(100,100,15,15,Point3d);
sd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3d}(s);
subdivide_duals!(sd, Barycenter());

f = draw(sd)
f
```
```{julia}
quadrants(x) = Int(x[1] > 50) + 2*Int(x[2] > 50)

function cover_mesh(partition_function, s)
  vertex_partition = map(partition_function, s[:point])
  parts = map(unique(vertex_partition)) do p
    vp = findall(i->i==p, vertex_partition)
    sp = non(negate(Subobject(s; V=vp)))
  end
  return parts
end
quads = cover_mesh(quadrants, s)
q = quads[1]
draw(q)
```
```{julia}
draw(quads[3])
```

```{julia}
q = join(quads[1], quads[3])
draw(q)
```

```{julia}
draw(meet(quads[1], quads[2]))
```

```{julia}
draw(quads)
```

```{julia}
using Catlab.FreeDiagrams
function nerve(cover::Vector{T}) where T <: Subobject
  n = length(cover)
  map(1:n) do i
    map(i:n) do j
      ui,uj = cover[i], cover[j]
      uij = meet(ui,uj)
      (uij, i, j)
    end
  end |> Iterators.flatten
end
D = nerve(quads)
```

```{julia}
function circle(n, c)
  mesh = EmbeddedDeltaSet1D{Bool, Point2D}()
  map(range(0, 2pi - (pi/(2^(n-1))); step=pi/(2^(n-1)))) do t
    add_vertex!(mesh, point=Point2D(cos(t),sin(t))*(c/2pi))
  end
  add_edges!(mesh, 1:(nv(mesh)-1), 2:nv(mesh))
  add_edge!(mesh, nv(mesh), 1)
  dualmesh = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(mesh)
  subdivide_duals!(dualmesh, Circumcenter())
  mesh,dualmesh
end
mesh,dualmesh = circle(9, 100)
```


```{julia}
draw(dualmesh)
```

```{julia}
function pizza_slices(x)
  (x[1] > 0) + 2*(x[2] > 0)
end
circ_quads = cover_mesh(pizza_slices,dualmesh)
draw(circ_quads[1])
draw(circ_quads)
```

```{julia}
function finsetdiagram(cover; object=:V)
  n = length(cover)
  u1 = cover[1]
  f = hom(u1)
  X = codom(f)
  ObT = FinSet
  HomT = Catlab.CategoricalAlgebra.FinFunction
  homs = [(hom(cover[i]).components[object], i+1, 1) for i in 1:n]
  opens = dom.(hom.(cover))
  obs = [X]
  append!(obs, opens)
  obs = FinSet.(nparts.(obs, object))
  # @show obs
  # edge_homs = map(homs) do (ui, s, t)
  #   println("$s --> $t = $ui")
  # end
  diag = FreeDiagram(obs, homs)
end

diag = finsetdiagram(quads)
```

```{julia}
using Catlab.Sheaves: FVect
import Catlab.Sheaves: pullback_matrix

Catlab.dom(m::Matrix) = FinSet(size(m, 2))
Catlab.codom(m::Matrix) = FinSet(size(m, 1))

function vectdiagram(diag)
  obs = diag[:ob]
  homs = map(enumerate(diag[edges(diag), :hom])) do (e, f)
    (pullback_matrix(f), diag[e, :src], diag[e,:tgt])
  end
  # FreeDiagram(obs, homs)
  return obs, homs
end
vectdiagram(diag)
```

```{julia}
import Catlab.Sheaves: AbstractCover

struct NerveCover{T, X} <: AbstractCover
  vertices::Dict{T, Int}
  basis::Vector{X}
end

function NerveCover(subobjects::Vector{X}) where X <: Subobject
  lookup = enumerate(subobjects)
  vertices = Dict{Int, Int}(i=>i for (i, _) in lookup)
  return NerveCover{Int, Subobject}(vertices, subobjects)
end

function NerveCover(subobjects::Dict{T,Subobject}) where T
  lookup = enumerate(keys(subobjects))
  vertices = Dict{T, Int}(k=>i for (i, k) in lookup)
  opens = collect(values(subobjects))
  return NerveCover{T, Subobject}(vertices, opens)
end

Base.length(K::NerveCover) = length(K.basis)

Base.show(io::IO, K::NerveCover) = begin
  print(io, "$(typeof(K)) with $(length(K)) generating opens:\n\tNV, NE, NT")
  for (i, ui) in enumerate(K.basis)
    print(io, "\n  ")
    V = nv(dom(hom(ui)))
    E = ne(dom(hom(ui)))
    T = ntriangles(dom(hom(ui)))
    print(io, "K[$i]: $V, $E, $T")
  end
end

import Catlab.CategoricalAlgebra.CSets: SubACSetComponentwise

function Base.show(io::IO, U::SubACSetComponentwise{X}) where X <: HasDeltaSet
  print(io, "Subdelta-set")
  V = nv(dom(hom(U)))
  E = ne(dom(hom(U)))
  T = ntriangles(dom(hom(U)))
  print(io, "with size $V, $E, $T")
  V = nv(codom(hom(U)))
  E = ne(codom(hom(U)))
  T = ntriangles(codom(hom(U)))
  print(io, " of object with size $V, $E, $T")
end

function Base.getindex(K::NerveCover, I::Vararg{Int})
  map(I) do i
    K.basis[i]
  end |> x->foldl(meet, x)
end

using Combinatorics: powerset
function resolve(K::NerveCover, dim=2)
  map(powerset(K.vertices, 1, dim)) do S
    S => K[S...]
  end |> Dict
end
```
```{julia}
K = NerveCover(quads)
K[1,2]
```
```{julia}
resolve(K)
```

```{julia}
resolve(K, 3)
```
