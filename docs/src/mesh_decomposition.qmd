# Mesh Decomposition

```{julia}
using CombinatorialSpaces
using GeometryBasics: Point3d
using LinearAlgebra: norm
using CairoMakie
using Catlab

```

```{julia}
function draw(mesh; color=:blue)
  f = Figure()
  ax = CairoMakie.Axis(f[1,1])
  draw!(ax, mesh, color=color)
  return f
end

function draw!(ax, mesh::EmbeddedDeltaDualComplex1D; color=:blue)
  ax = scatter!(ax, mesh[:point], color=color)
end

function draw!(ax, mesh::Union{EmbeddedDeltaSet2D,EmbeddedDeltaDualComplex2D}; color=:blue)
  wireframe!(ax, mesh, color=color)
  return ax
end

function draw!(ax, submesh::Subobject; color=:orange)
  ϕ = hom(submesh)
  @show nparts(dom(ϕ), :V)
  @show nparts(codom(ϕ), :V)
  draw!(ax, codom(ϕ),color=color)
  draw!(ax, dom(ϕ), color=:orange)
end


function draw(cover::Vector{T}; color=:blue) where T <: Subobject
  f = Figure()
  n = length(cover)
  for i in 1:n
    for j in i:n
      ax = CairoMakie.Axis(f[i,j])
      ui,uj = cover[i], cover[j]
      # ϕ = hom(meet(ui,uj))
      # draw!(ax, codom(ϕ), color=:blue)
      # draw!(ax, dom(ϕ), color=color)
      draw!(ax, meet(ui,uj), color=color)
    end
  end
  f
end
```
```{julia}
s = triangulated_grid(100,100,15,15,Point3d);
sd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3d}(s);
subdivide_duals!(sd, Barycenter());

f = draw(sd)
f
```
```{julia}
quadrants(x) = Int(x[1] > 50) + 2*Int(x[2] > 50)

function cover_mesh(partition_function, s)
  vertex_partition = map(partition_function, s[:point])
  parts = map(unique(vertex_partition)) do p
    vp = findall(i->i==p, vertex_partition)
    sp = non(negate(Subobject(s; V=vp)))
  end
  return parts
end
quads = cover_mesh(quadrants, s)
q = quads[1]
draw(q)
```
```{julia}
draw(quads[3])
```

```{julia}
q = join(quads[1], quads[3])
draw(q)
```

```{julia}
draw(meet(quads[1], quads[2]))
```

```{julia}
draw(quads)
```

```{julia}
using Catlab.FreeDiagrams
function nerve(cover::Vector{T}) where T <: Subobject
  n = length(cover)
  map(1:n) do i
    map(i:n) do j
      ui,uj = cover[i], cover[j]
      uij = meet(ui,uj)
      (uij, i, j)
    end
  end |> Iterators.flatten
end
D = nerve(quads)
```

```{julia}
function circle(n, c)
  mesh = EmbeddedDeltaSet1D{Bool, Point2D}()
  map(range(0, 2pi - (pi/(2^(n-1))); step=pi/(2^(n-1)))) do t
    add_vertex!(mesh, point=Point2D(cos(t),sin(t))*(c/2pi))
  end
  add_edges!(mesh, 1:(nv(mesh)-1), 2:nv(mesh))
  add_edge!(mesh, nv(mesh), 1)
  dualmesh = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(mesh)
  subdivide_duals!(dualmesh, Circumcenter())
  mesh,dualmesh
end
mesh,dualmesh = circle(9, 100)
```



```{julia}
draw(dualmesh)
```

```{julia}
function pizza_slices(x)
  (x[1] > 0) + 2*(x[2] > 0)
end
circ_quads = cover_mesh(pizza_slices,dualmesh)
draw(circ_quads[1])
draw(circ_quads)
```

```{julia}
function finsetdiagram(cover; object=:V)
  n = length(cover)
  u1 = cover[1]
  f = hom(u1)
  X = codom(f)
  ObT = FinSet
  HomT = Catlab.CategoricalAlgebra.FinFunction
  homs = [(hom(cover[i]).components[object], i+1, 1) for i in 1:n]
  opens = dom.(hom.(cover))
  obs = [X]
  append!(obs, opens)
  obs = FinSet.(nparts.(obs, object))
  # @show obs
  # edge_homs = map(homs) do (ui, s, t)
  #   println("$s --> $t = $ui")
  # end
  diag = FreeDiagram(obs, homs)
end

diag = finsetdiagram(quads)
```

```{julia}
using Catlab.Sheaves: FVect
import Catlab.Sheaves: pullback_matrix

Catlab.dom(m::Matrix) = FinSet(size(m, 2))
Catlab.codom(m::Matrix) = FinSet(size(m, 1))

function vectdiagram(diag)
  obs = diag[:ob]
  homs = map(enumerate(diag[edges(diag), :hom])) do (e, f)
    (pullback_matrix(f), diag[e, :src], diag[e,:tgt])
  end
  @show homs
  map(homs) do f
    @show dom(f[1]), codom(f[1])
  end
  FreeDiagram(obs, homs)
end
vectdiagram(diag)
```

```{julia}
function freediagram(cover; nerve_dimension=0)
  nerve_dimension >= 0 || error("nerve_dimension must be nonnegative")
  n = length(cover)
  u1 = cover[1]
  f = hom(u1)
  X = codom(f)
  ObT = typeof(X)
  HomT = typeof(f)
  homs = [(hom(cover[i]), i+1, 1) for i in 1:n]
  opens = dom.(hom.(cover))
  obs = [X]
  append!(obs, opens)
  if nerve_dimension == 1
    D = nerve(cover)
    edge_homs = map(D) do (uij, i, j)
      f = hom(uij)
      f.codom = obs[i+1]
      return (f, i+1, j+1)
    end
    for e in edge_homs
      @show e[2], e[3], nv(dom(e[1])), nv(codom(e[1]))
    end
    append!(homs, edge_homs)
  end
  nerve_dimension < 2 || error("nerve_dimension must <= 1")
  diag = FreeDiagram{ObT,HomT}(obs, homs)
end

freediagram(quads)
freediagram(quads, nerve_dimension=1)
```